// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'github.com/larksuite/oapi-sdk-go/v3/event'{

	// @ts-ignore
	import * as http from 'golang/net/http'
	// @ts-ignore
	import * as larkcore from 'github.com/larksuite/oapi-sdk-go/v3/core'
	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import type {int,Alias,bool,Struct,GoError,error,Ref,map} from 'go'
	//"{\"challenge\":\"%s\"}"
	export const ChallengeResponseFormat:string
	//"Content-Type"
	export const ContentTypeHeader:string
	//"application/json"
	export const ContentTypeJson:string
	export interface DecryptErr extends Struct<DecryptErr>,Error,GoError{

			message:string
			error():string
	}
	//"application/json; charset=utf-8"
	export const DefaultContentType:string
	export interface EventBase extends Struct<EventBase>{

			ts:string
			uuid:string
			token:string
			type:string
	}
	export function eventDecrypt(encrypt:string,secret:string):Uint8Array

	export interface EventEncryptMsg extends Struct<EventEncryptMsg>{

			encrypt:string
	}
	export interface EventFuzzy extends Struct<EventFuzzy>{

			encrypt:string
			schema:string
			token:string
			type:string
			challenge:string
			header:Ref<EventHeader>
			event:Ref<Struct<{
			
				type:any
			}>>
	}
	export interface EventHandler{

			event():any
			handle(v2:context.Context,v1:any)/*error*/
	}
	export interface EventHandlerModel{

			rawReq(req:Ref<EventReq>):void
	}
	export interface EventHeader extends Struct<EventHeader>{

			eventID:string
			eventType:string
			appID:string
			tenantKey:string
			createTime:string
			token:string
	}
	export interface EventReq extends Struct<EventReq>{

			header:map<string,string[]>
			body:Uint8Array
			requestURI:string
			requestId():string
	}
	//"X-Lark-Request-Nonce"
	export const EventRequestNonce:string
	//"X-Lark-Request-Timestamp"
	export const EventRequestTimestamp:string
	export interface EventResp extends Struct<EventResp>{

			header:http.Header
			body:Uint8Array
			statusCode:int
	}
	//"X-Lark-Signature"
	export const EventSignature:string
	export interface EventV1Header extends Struct<EventV1Header>{

			appID:string
			openAppID:string
			openID:string
			tenantKey:string
			type:string
	}
	export interface EventV2Base extends Struct<EventV2Base>{

			schema:string
			header:Ref<EventHeader>
			tenantKey():string
	}
	export interface EventV2Body extends Struct<EventV2Body>{

			eventV2Base:EventV2Base
			challenge:string
			event:any
			type:string
	}
	export interface IReqHandler{

			handle(ctx:context.Context,req:Ref<EventReq>):Ref<EventResp>
			logger():larkcore.Logger
	}
	export interface OptionFunc extends Alias<(config:Ref<larkcore.Config>)=>void>{

	}
	export interface ReqType extends string{

	}
	export const ReqTypeChallenge:ReqType
	export const ReqTypeEventCallBack:ReqType
	export function signature(timestamp:string,nonce:string,eventEncryptKey:string,body:string):string

	//"{\"msg\":\"%s\"}"
	export const WebhookResponseFormat:string
	export function withLogLevel(logLevel:larkcore.LogLevel):OptionFunc

	export function withLogger(logger:larkcore.Logger):OptionFunc

	export function withSkipSignVerify(skipSignVerify:bool):OptionFunc

	export function emptyEventV2Body():EventV2Body
	export function emptyRefEventV2Body():Ref<EventV2Body>
	export function refOfEventV2Body(x:EventV2Body,v:Ref<EventV2Body>)
	export function unRefEventV2Body(v:Ref<EventV2Body>):EventV2Body
	export function emptyEventBase():EventBase
	export function emptyRefEventBase():Ref<EventBase>
	export function refOfEventBase(x:EventBase,v:Ref<EventBase>)
	export function unRefEventBase(v:Ref<EventBase>):EventBase
	export function emptyEventFuzzy():EventFuzzy
	export function emptyRefEventFuzzy():Ref<EventFuzzy>
	export function refOfEventFuzzy(x:EventFuzzy,v:Ref<EventFuzzy>)
	export function unRefEventFuzzy(v:Ref<EventFuzzy>):EventFuzzy
	export function emptyEventHeader():EventHeader
	export function emptyRefEventHeader():Ref<EventHeader>
	export function refOfEventHeader(x:EventHeader,v:Ref<EventHeader>)
	export function unRefEventHeader(v:Ref<EventHeader>):EventHeader
	export function emptyEventResp():EventResp
	export function emptyRefEventResp():Ref<EventResp>
	export function refOfEventResp(x:EventResp,v:Ref<EventResp>)
	export function unRefEventResp(v:Ref<EventResp>):EventResp
	export function emptyEventV1Header():EventV1Header
	export function emptyRefEventV1Header():Ref<EventV1Header>
	export function refOfEventV1Header(x:EventV1Header,v:Ref<EventV1Header>)
	export function unRefEventV1Header(v:Ref<EventV1Header>):EventV1Header
	export function emptyEventV2Base():EventV2Base
	export function emptyRefEventV2Base():Ref<EventV2Base>
	export function refOfEventV2Base(x:EventV2Base,v:Ref<EventV2Base>)
	export function unRefEventV2Base(v:Ref<EventV2Base>):EventV2Base
	export function emptyEventEncryptMsg():EventEncryptMsg
	export function emptyRefEventEncryptMsg():Ref<EventEncryptMsg>
	export function refOfEventEncryptMsg(x:EventEncryptMsg,v:Ref<EventEncryptMsg>)
	export function unRefEventEncryptMsg(v:Ref<EventEncryptMsg>):EventEncryptMsg
	export function emptyEventReq():EventReq
	export function emptyRefEventReq():Ref<EventReq>
	export function refOfEventReq(x:EventReq,v:Ref<EventReq>)
	export function unRefEventReq(v:Ref<EventReq>):EventReq
}