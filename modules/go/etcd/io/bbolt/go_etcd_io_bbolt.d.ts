// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'go.etcd.io/bbolt'{

	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as fs from 'golang/io/fs'
	// @ts-ignore
	import * as os from 'golang/os'
	// @ts-ignore
	import * as go from 'go'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as fmt from 'golang/fmt'
	// @ts-ignore
	import type {error,Ref,uint64,Alias,uintptr,bool,reserved,GoError,Struct,int,int64,float,float64} from 'go'
	export interface Bucket extends Struct<Bucket>{

			fillPercent:float64
			tx():Ref<Tx>
			writable():bool
			cursor():Ref<Cursor>
			bucket(name:Uint8Array):Ref<Bucket>
			createBucket(key:Uint8Array):Ref<Bucket>
			createBucketIfNotExists(key:Uint8Array):Ref<Bucket>
			deleteBucket(key:Uint8Array)/*error*/
			get(key:Uint8Array):Uint8Array
			put(key:Uint8Array,value:Uint8Array)/*error*/
			delete(key:Uint8Array)/*error*/
			sequence():uint64
			setSequence(v:uint64)/*error*/
			nextSequence():uint64
			forEach(v1:(k:Uint8Array,v:Uint8Array)=>void/*error*/)/*error*/
			forEachBucket(v1:(k:Uint8Array)=>void/*error*/)/*error*/
			stats():BucketStats
	}
	export interface BucketStats extends Struct<BucketStats>{

			branchPageN:int
			branchOverflowN:int
			leafPageN:int
			leafOverflowN:int
			keyN:int
			depth:int
			branchAlloc:int
			branchInuse:int
			leafAlloc:int
			leafInuse:int
			bucketN:int
			inlineBucketN:int
			inlineBucketInuse:int
			add(other:BucketStats):void
	}
	export interface CheckOption extends Alias<(options:Ref<reserved>)=>void>{

	}
	export function compact(dst:Ref<DB>,src:Ref<DB>,txMaxSize:int64)/*error*/

	export interface Cursor extends Struct<Cursor>{

			bucket():Ref<Bucket>
			first():[Uint8Array,Uint8Array]
			last():[Uint8Array,Uint8Array]
			next():[Uint8Array,Uint8Array]
			prev():[Uint8Array,Uint8Array]
			seek(seek:Uint8Array):[Uint8Array,Uint8Array]
			delete()/*error*/
	}
	export interface DB extends Struct<DB>,fmt.GoStringer,fmt.Stringer,io.Closer{

			strictMode:bool
			noSync:bool
			noFreelistSync:bool
			freelistType:FreelistType
			noGrowSync:bool
			preLoadFreelist:bool
			mmapFlags:int
			maxBatchSize:int
			maxBatchDelay:time.Duration
			allocSize:int
			mlock:bool
			path():string
			goString():string
			string():string
			close():error
			begin(writable:bool):Ref<Tx>
			update(v1:(v1:Ref<Tx>)=>void/*error*/)/*error*/
			view(v1:(v1:Ref<Tx>)=>void/*error*/)/*error*/
			batch(v1:(v1:Ref<Tx>)=>void/*error*/)/*error*/
			sync()/*error*/
			stats():Stats
			info():Ref<Info>
			isReadOnly():bool
	}
	//16777216
	export const DefaultAllocSize:int
	//0.5
	export const DefaultFillPercent:float
	export const DefaultMaxBatchDelay:time.Duration
	//1000
	export const DefaultMaxBatchSize:int
	export const DefaultOptions:Ref<Options>
	export const ErrBucketExists:GoError
	export const ErrBucketNameRequired:GoError
	export const ErrBucketNotFound:GoError
	export const ErrChecksum:GoError
	export const ErrDatabaseNotOpen:GoError
	export const ErrDatabaseOpen:GoError
	export const ErrDatabaseReadOnly:GoError
	export const ErrFreePagesNotLoaded:GoError
	export const ErrIncompatibleValue:GoError
	export const ErrInvalid:GoError
	export const ErrInvalidMapping:GoError
	export const ErrKeyRequired:GoError
	export const ErrKeyTooLarge:GoError
	export const ErrTimeout:GoError
	export const ErrTxClosed:GoError
	export const ErrTxNotWritable:GoError
	export const ErrValueTooLarge:GoError
	export const ErrVersionMismatch:GoError
	export const FreelistArrayType:FreelistType
	export const FreelistMapType:FreelistType
	export interface FreelistType extends Alias<string>{

	}
	export function hexKVStringer():KVStringer

	//false
	export const IgnoreNoSync:bool
	export interface Info extends Struct<Info>{

			data:uintptr
			pageSize:int
	}
	export interface KVStringer{

			keyToString(v1:Uint8Array):string
			valueToString(v1:Uint8Array):string
	}
	//32768
	export const MaxKeySize:int
	//2147483646
	export const MaxValueSize:int
	export function open(path:string,mode:fs.FileMode,options:Ref<Options>):Ref<DB>

	export interface Options extends Struct<Options>{

			timeout:time.Duration
			noGrowSync:bool
			noFreelistSync:bool
			preLoadFreelist:bool
			freelistType:FreelistType
			readOnly:bool
			mmapFlags:int
			initialMmapSize:int
			pageSize:int
			noSync:bool
			openFile:(v3:string,v2:int,v1:fs.FileMode)=>Ref<os.File>
			mlock:bool
	}
	export interface PageInfo extends Struct<PageInfo>{

			id:int
			type:string
			count:int
			overflowCount:int
	}
	export interface Stats extends Struct<Stats>{

			txStats:TxStats
			freePageN:int
			pendingPageN:int
			freeAlloc:int
			freelistInuse:int
			txN:int
			openTxN:int
			sub(other:Ref<Stats>):Stats
	}
	export interface Tx extends Struct<Tx>,io.WriterTo{

			writeFlag:int
			id():int
			db():Ref<DB>
			size():int64
			writable():bool
			cursor():Ref<Cursor>
			stats():TxStats
			bucket(name:Uint8Array):Ref<Bucket>
			createBucket(name:Uint8Array):Ref<Bucket>
			createBucketIfNotExists(name:Uint8Array):Ref<Bucket>
			deleteBucket(name:Uint8Array)/*error*/
			forEach(v1:(name:Uint8Array,b:Ref<Bucket>)=>void/*error*/)/*error*/
			onCommit(fn:()=>void):void
			commit()/*error*/
			rollback()/*error*/
			copy(w:io.Writer)/*error*/
			writeTo(w:io.Writer):int64
			copyFile(path:string,mode:fs.FileMode)/*error*/
			page(id:int):Ref<PageInfo>
			check():go.ChanRecv<error>
			checkWithOptions(...options:CheckOption[]):go.ChanRecv<error>
	}
	export interface TxStats extends Struct<TxStats>{

			pageCount:int64
			pageAlloc:int64
			cursorCount:int64
			nodeCount:int64
			nodeDeref:int64
			rebalance:int64
			rebalanceTime:time.Duration
			split:int64
			spill:int64
			spillTime:time.Duration
			write:int64
			writeTime:time.Duration
			sub(other:Ref<TxStats>):TxStats
			getPageCount():int64
			incPageCount(delta:int64):int64
			getPageAlloc():int64
			incPageAlloc(delta:int64):int64
			getCursorCount():int64
			incCursorCount(delta:int64):int64
			getNodeCount():int64
			incNodeCount(delta:int64):int64
			getNodeDeref():int64
			incNodeDeref(delta:int64):int64
			getRebalance():int64
			incRebalance(delta:int64):int64
			getRebalanceTime():time.Duration
			incRebalanceTime(delta:time.Duration):time.Duration
			getSplit():int64
			incSplit(delta:int64):int64
			getSpill():int64
			incSpill(delta:int64):int64
			getSpillTime():time.Duration
			incSpillTime(delta:time.Duration):time.Duration
			getWrite():int64
			incWrite(delta:int64):int64
			getWriteTime():time.Duration
			incWriteTime(delta:time.Duration):time.Duration
	}
	export function withKVStringer(kvStringer:KVStringer):CheckOption

	export function emptyBucket():Bucket
	export function emptyRefBucket():Ref<Bucket>
	export function refOfBucket(x:Bucket,v:Ref<Bucket>)
	export function unRefBucket(v:Ref<Bucket>):Bucket
	export function emptyBucketStats():BucketStats
	export function emptyRefBucketStats():Ref<BucketStats>
	export function refOfBucketStats(x:BucketStats,v:Ref<BucketStats>)
	export function unRefBucketStats(v:Ref<BucketStats>):BucketStats
	export function emptyDB():DB
	export function emptyRefDB():Ref<DB>
	export function refOfDB(x:DB,v:Ref<DB>)
	export function unRefDB(v:Ref<DB>):DB
	export function emptyInfo():Info
	export function emptyRefInfo():Ref<Info>
	export function refOfInfo(x:Info,v:Ref<Info>)
	export function unRefInfo(v:Ref<Info>):Info
	export function emptyOptions():Options
	export function emptyRefOptions():Ref<Options>
	export function refOfOptions(x:Options,v:Ref<Options>)
	export function unRefOptions(v:Ref<Options>):Options
	export function emptyStats():Stats
	export function emptyRefStats():Ref<Stats>
	export function refOfStats(x:Stats,v:Ref<Stats>)
	export function unRefStats(v:Ref<Stats>):Stats
	export function emptyCursor():Cursor
	export function emptyRefCursor():Ref<Cursor>
	export function refOfCursor(x:Cursor,v:Ref<Cursor>)
	export function unRefCursor(v:Ref<Cursor>):Cursor
	export function emptyPageInfo():PageInfo
	export function emptyRefPageInfo():Ref<PageInfo>
	export function refOfPageInfo(x:PageInfo,v:Ref<PageInfo>)
	export function unRefPageInfo(v:Ref<PageInfo>):PageInfo
	export function emptyTx():Tx
	export function emptyRefTx():Ref<Tx>
	export function refOfTx(x:Tx,v:Ref<Tx>)
	export function unRefTx(v:Ref<Tx>):Tx
	export function emptyTxStats():TxStats
	export function emptyRefTxStats():Ref<TxStats>
	export function refOfTxStats(x:TxStats,v:Ref<TxStats>)
	export function unRefTxStats(v:Ref<TxStats>):TxStats
}