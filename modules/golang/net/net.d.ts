// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/net'{

	// @ts-ignore
	import * as os from 'golang/os'
	// @ts-ignore
	import * as netip from 'golang/net/netip'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as go from 'go'
	// @ts-ignore
	import * as syscall from 'golang/syscall'
	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import type {Struct,error,int,Nothing,Alias,uint,byte,uint16,bool,GoError,int64,Ref} from 'go'
	export interface Addr{

			network():string
			string():string
	}
	export interface AddrError extends Struct<AddrError>,Error,GoError{

			err:string
			addr:string
			error():string
			timeout():bool
			temporary():bool
	}
	export interface Buffers extends Array<Uint8Array>{

			writeTo(w:io.Writer):int64
			read(p:Uint8Array):int
	}
	export function cidrMask(ones:int,bits:int):IPMask

	export interface Conn extends io.Closer{

			close():error
			localAddr():Addr
			read(b:Uint8Array):int
			remoteAddr():Addr
			setDeadline(t:time.Time)/*error*/
			setReadDeadline(t:time.Time)/*error*/
			setWriteDeadline(t:time.Time)/*error*/
			write(b:Uint8Array):int
	}
	export interface DNSConfigError extends Struct<DNSConfigError>,Error,GoError{

			err:GoError
			unwrap()/*error*/
			error():string
			timeout():bool
			temporary():bool
	}
	export interface DNSError extends Struct<DNSError>,Error,GoError{

			err:string
			name:string
			server:string
			isTimeout:bool
			isTemporary:bool
			isNotFound:bool
			error():string
			timeout():bool
			temporary():bool
	}
	export const DefaultResolver:Ref<Resolver>
	export function dial(network:string,address:string):Conn

	export function dialIP(network:string,laddr:Ref<IPAddr>,raddr:Ref<IPAddr>):Ref<IPConn>

	export function dialTCP(network:string,laddr:Ref<TCPAddr>,raddr:Ref<TCPAddr>):Ref<TCPConn>

	export function dialTimeout(network:string,address:string,timeout:time.Duration):Conn

	export function dialUDP(network:string,laddr:Ref<UDPAddr>,raddr:Ref<UDPAddr>):Ref<UDPConn>

	export function dialUnix(network:string,laddr:Ref<UnixAddr>,raddr:Ref<UnixAddr>):Ref<UnixConn>

	export interface Dialer extends Struct<Dialer>{

			timeout:time.Duration
			deadline:time.Time
			localAddr:Addr
			dualStack:bool
			fallbackDelay:time.Duration
			keepAlive:time.Duration
			resolver:Ref<Resolver>
			cancel:go.ChanRecv<Nothing>
			control:(network:string,address:string,c:syscall.RawConn)=>void/*error*/
			controlContext:(ctx:context.Context,network:string,address:string,c:syscall.RawConn)=>void/*error*/
			multipathTCP():bool
			setMultipathTCP(use:bool):void
			dial(network:string,address:string):Conn
			dialContext(ctx:context.Context,network:string,address:string):Conn
	}
	export const ErrClosed:GoError
	export const ErrWriteToConnected:GoError
	export interface Error{

			temporary():bool
			timeout():bool
	}
	export function fileConn(f:Ref<os.File>):Conn

	export function fileListener(f:Ref<os.File>):Listener

	export function filePacketConn(f:Ref<os.File>):PacketConn

	export const FlagBroadcast:Flags
	export const FlagLoopback:Flags
	export const FlagMulticast:Flags
	export const FlagPointToPoint:Flags
	export const FlagRunning:Flags
	export const FlagUp:Flags
	export interface Flags extends uint{

	string():string
	}
	export interface HardwareAddr extends Uint8Array{

			string():string
	}
	export interface IP extends Uint8Array{

			isUnspecified():bool
			isLoopback():bool
			isPrivate():bool
			isMulticast():bool
			isInterfaceLocalMulticast():bool
			isLinkLocalMulticast():bool
			isLinkLocalUnicast():bool
			isGlobalUnicast():bool
			to4():IP
			to16():IP
			defaultMask():IPMask
			mask(mask:IPMask):IP
			string():string
			marshalText():Uint8Array
			unmarshalText(text:Uint8Array)/*error*/
			equal(x:IP):bool
	}
	export interface IPAddr extends Struct<IPAddr>,Addr{

			ip:IP
			zone:string
			network():string
			string():string
	}
	export interface IPConn extends io.ReadWriteCloser,PacketConn,syscall.Conn,io.ReadWriter,Conn,io.ReadCloser,io.WriteCloser,Struct<IPConn>{

			syscallConn():syscall.RawConn
			readFromIP(b:Uint8Array):[int,Ref<IPAddr>]
			readFrom(b:Uint8Array):[int,Addr]
			readMsgIP(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<IPAddr>]
			writeToIP(b:Uint8Array,addr:Ref<IPAddr>):int
			writeTo(b:Uint8Array,addr:Addr):int
			writeMsgIP(b:Uint8Array,oob:Uint8Array,addr:Ref<IPAddr>):[int,int]
	}
	export interface IPMask extends Uint8Array{

			size():[int,int]
			string():string
	}
	export interface IPNet extends Struct<IPNet>,Addr{

			ip:IP
			mask:IPMask
			contains(ip:IP):bool
			network():string
			string():string
	}
	export function iPv4(a:byte,b:byte,c:byte,d:byte):IP

	export function iPv4Mask(a:byte,b:byte,c:byte,d:byte):IPMask

	export const IPv4allrouter:IP
	export const IPv4allsys:IP
	export const IPv4bcast:IP
	//4
	export const IPv4len:int
	export const IPv4zero:IP
	export const IPv6interfacelocalallnodes:IP
	//16
	export const IPv6len:int
	export const IPv6linklocalallnodes:IP
	export const IPv6linklocalallrouters:IP
	export const IPv6loopback:IP
	export const IPv6unspecified:IP
	export const IPv6zero:IP
	export interface Interface extends Struct<Interface>{

			index:int
			mtu:int
			name:string
			hardwareAddr:HardwareAddr
			flags:Flags
			addrs():Addr[]
			multicastAddrs():Addr[]
	}
	export function interfaceAddrs():Addr[]

	export function interfaceByIndex(index:int):Ref<Interface>

	export function interfaceByName(name:string):Ref<Interface>

	export function interfaces():Interface[]

	export interface InvalidAddrError extends Alias<string>,GoError{

	error():string
	timeout():bool
	temporary():bool
	}
	export function joinHostPort(host:string,port:string):string

	export function listen(network:string,address:string):Listener

	export interface ListenConfig extends Struct<ListenConfig>{

			control:(network:string,address:string,c:syscall.RawConn)=>void/*error*/
			keepAlive:time.Duration
			multipathTCP():bool
			setMultipathTCP(use:bool):void
			listen(ctx:context.Context,network:string,address:string):Listener
			listenPacket(ctx:context.Context,network:string,address:string):PacketConn
	}
	export function listenIP(network:string,laddr:Ref<IPAddr>):Ref<IPConn>

	export function listenMulticastUDP(network:string,ifi:Ref<Interface>,gaddr:Ref<UDPAddr>):Ref<UDPConn>

	export function listenPacket(network:string,address:string):PacketConn

	export function listenTCP(network:string,laddr:Ref<TCPAddr>):Ref<TCPListener>

	export function listenUDP(network:string,laddr:Ref<UDPAddr>):Ref<UDPConn>

	export function listenUnix(network:string,laddr:Ref<UnixAddr>):Ref<UnixListener>

	export function listenUnixgram(network:string,laddr:Ref<UnixAddr>):Ref<UnixConn>

	export interface Listener extends io.Closer{

			accept():Conn
			addr():Addr
			close():error
	}
	export function lookupAddr(addr:string):string[]

	export function lookupCNAME(host:string):string

	export function lookupHost(host:string):string[]

	export function lookupIP(host:string):IP[]

	export function lookupMX(name:string):Ref<MX>[]

	export function lookupNS(name:string):Ref<NS>[]

	export function lookupPort(network:string,service:string):int

	export function lookupSRV(service:string,proto:string,name:string):[string,Ref<SRV>[]]

	export function lookupTXT(name:string):string[]

	export interface MX extends Struct<MX>{

			host:string
			pref:uint16
	}
	export interface NS extends Struct<NS>{

			host:string
	}
	export interface OpError extends Struct<OpError>,Error,GoError{

			op:string
			net:string
			source:Addr
			addr:Addr
			err:GoError
			unwrap()/*error*/
			error():string
			timeout():bool
			temporary():bool
	}
	export interface PacketConn extends io.Closer{

			close():error
			localAddr():Addr
			readFrom(p:Uint8Array):[int,Addr]
			setDeadline(t:time.Time)/*error*/
			setReadDeadline(t:time.Time)/*error*/
			setWriteDeadline(t:time.Time)/*error*/
			writeTo(p:Uint8Array,addr:Addr):int
	}
	export function parseCIDR(s:string):[IP,Ref<IPNet>]

	export interface ParseError extends GoError,Struct<ParseError>,Error{

			type:string
			text:string
			error():string
			timeout():bool
			temporary():bool
	}
	export function parseIP(s:string):IP

	export function parseMAC(s:string):HardwareAddr

	export function pipe():[Conn,Conn]

	export function resolveIPAddr(network:string,address:string):Ref<IPAddr>

	export function resolveTCPAddr(network:string,address:string):Ref<TCPAddr>

	export function resolveUDPAddr(network:string,address:string):Ref<UDPAddr>

	export function resolveUnixAddr(network:string,address:string):Ref<UnixAddr>

	export interface Resolver extends Struct<Resolver>{

			preferGo:bool
			strictErrors:bool
			dial:(ctx:context.Context,network:string,address:string)=>Conn
			lookupHost(ctx:context.Context,host:string):string[]
			lookupIPAddr(ctx:context.Context,host:string):IPAddr[]
			lookupIP(ctx:context.Context,network:string,host:string):IP[]
			lookupNetIP(ctx:context.Context,network:string,host:string):netip.Addr[]
			lookupPort(ctx:context.Context,network:string,service:string):int
			lookupCNAME(ctx:context.Context,host:string):string
			lookupSRV(ctx:context.Context,service:string,proto:string,name:string):[string,Ref<SRV>[]]
			lookupMX(ctx:context.Context,name:string):Ref<MX>[]
			lookupNS(ctx:context.Context,name:string):Ref<NS>[]
			lookupTXT(ctx:context.Context,name:string):string[]
			lookupAddr(ctx:context.Context,addr:string):string[]
	}
	export interface SRV extends Struct<SRV>{

			target:string
			port:uint16
			priority:uint16
			weight:uint16
	}
	export function splitHostPort(hostport:string):[string,string]

	export interface TCPAddr extends Struct<TCPAddr>,Addr{

			ip:IP
			port:int
			zone:string
			addrPort():netip.AddrPort
			network():string
			string():string
	}
	export function tcpAddrFromAddrPort(addr:netip.AddrPort):Ref<TCPAddr>

	export interface TCPConn extends syscall.Conn,io.ReadWriter,io.ReaderFrom,Conn,Struct<TCPConn>,io.ReadCloser,io.WriteCloser,io.ReadWriteCloser{

			syscallConn():syscall.RawConn
			readFrom(r:io.Reader):int64
			closeRead()/*error*/
			closeWrite()/*error*/
			setLinger(sec:int)/*error*/
			setKeepAlive(keepalive:bool)/*error*/
			setKeepAlivePeriod(d:time.Duration)/*error*/
			setNoDelay(noDelay:bool)/*error*/
			multipathTCP():bool
	}
	export interface TCPListener extends Struct<TCPListener>,Listener,syscall.Conn,io.Closer{

			syscallConn():syscall.RawConn
			acceptTCP():Ref<TCPConn>
			accept():Conn
			close():error
			addr():Addr
			setDeadline(t:time.Time)/*error*/
			file():Ref<os.File>
	}
	export interface UDPAddr extends Struct<UDPAddr>,Addr{

			ip:IP
			port:int
			zone:string
			addrPort():netip.AddrPort
			network():string
			string():string
	}
	export function udpAddrFromAddrPort(addr:netip.AddrPort):Ref<UDPAddr>

	export interface UDPConn extends io.WriteCloser,io.ReadWriteCloser,PacketConn,Struct<UDPConn>,syscall.Conn,io.ReadWriter,Conn,io.ReadCloser{

			syscallConn():syscall.RawConn
			readFromUDP(b:Uint8Array):[int,Ref<UDPAddr>]
			readFrom(b:Uint8Array):[int,Addr]
			readFromUDPAddrPort(b:Uint8Array):[int,netip.AddrPort]
			readMsgUDP(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<UDPAddr>]
			readMsgUDPAddrPort(b:Uint8Array,oob:Uint8Array):[int,int,int,netip.AddrPort]
			writeToUDP(b:Uint8Array,addr:Ref<UDPAddr>):int
			writeToUDPAddrPort(b:Uint8Array,addr:netip.AddrPort):int
			writeTo(b:Uint8Array,addr:Addr):int
			writeMsgUDP(b:Uint8Array,oob:Uint8Array,addr:Ref<UDPAddr>):[int,int]
			writeMsgUDPAddrPort(b:Uint8Array,oob:Uint8Array,addr:netip.AddrPort):[int,int]
	}
	export interface UnixAddr extends Struct<UnixAddr>,Addr{

			name:string
			net:string
			network():string
			string():string
	}
	export interface UnixConn extends io.ReadWriteCloser,Conn,syscall.Conn,io.ReadWriter,io.ReadCloser,io.WriteCloser,Struct<UnixConn>,PacketConn{

			syscallConn():syscall.RawConn
			closeRead()/*error*/
			closeWrite()/*error*/
			readFromUnix(b:Uint8Array):[int,Ref<UnixAddr>]
			readFrom(b:Uint8Array):[int,Addr]
			readMsgUnix(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<UnixAddr>]
			writeToUnix(b:Uint8Array,addr:Ref<UnixAddr>):int
			writeTo(b:Uint8Array,addr:Addr):int
			writeMsgUnix(b:Uint8Array,oob:Uint8Array,addr:Ref<UnixAddr>):[int,int]
	}
	export interface UnixListener extends Struct<UnixListener>,syscall.Conn,io.Closer,Listener{

			syscallConn():syscall.RawConn
			acceptUnix():Ref<UnixConn>
			accept():Conn
			close():error
			addr():Addr
			setDeadline(t:time.Time)/*error*/
			file():Ref<os.File>
			setUnlinkOnClose(unlink:bool):void
	}
	export interface UnknownNetworkError extends Alias<string>,GoError{

	error():string
	timeout():bool
	temporary():bool
	}
	export function emptyTCPListener():TCPListener
	export function emptyRefTCPListener():Ref<TCPListener>
	export function refOfTCPListener(x:TCPListener,v:Ref<TCPListener>)
	export function unRefTCPListener(v:Ref<TCPListener>):TCPListener
	export function emptyUnixAddr():UnixAddr
	export function emptyRefUnixAddr():Ref<UnixAddr>
	export function refOfUnixAddr(x:UnixAddr,v:Ref<UnixAddr>)
	export function unRefUnixAddr(v:Ref<UnixAddr>):UnixAddr
	export function emptyUnixListener():UnixListener
	export function emptyRefUnixListener():Ref<UnixListener>
	export function refOfUnixListener(x:UnixListener,v:Ref<UnixListener>)
	export function unRefUnixListener(v:Ref<UnixListener>):UnixListener
	export function emptyInterface():Interface
	export function emptyRefInterface():Ref<Interface>
	export function refOfInterface(x:Interface,v:Ref<Interface>)
	export function unRefInterface(v:Ref<Interface>):Interface
	export function emptyMX():MX
	export function emptyRefMX():Ref<MX>
	export function refOfMX(x:MX,v:Ref<MX>)
	export function unRefMX(v:Ref<MX>):MX
	export function emptyNS():NS
	export function emptyRefNS():Ref<NS>
	export function refOfNS(x:NS,v:Ref<NS>)
	export function unRefNS(v:Ref<NS>):NS
	export function emptyTCPAddr():TCPAddr
	export function emptyRefTCPAddr():Ref<TCPAddr>
	export function refOfTCPAddr(x:TCPAddr,v:Ref<TCPAddr>)
	export function unRefTCPAddr(v:Ref<TCPAddr>):TCPAddr
	export function emptyTCPConn():TCPConn
	export function emptyRefTCPConn():Ref<TCPConn>
	export function refOfTCPConn(x:TCPConn,v:Ref<TCPConn>)
	export function unRefTCPConn(v:Ref<TCPConn>):TCPConn
	export function emptyUDPAddr():UDPAddr
	export function emptyRefUDPAddr():Ref<UDPAddr>
	export function refOfUDPAddr(x:UDPAddr,v:Ref<UDPAddr>)
	export function unRefUDPAddr(v:Ref<UDPAddr>):UDPAddr
	export function emptyIPConn():IPConn
	export function emptyRefIPConn():Ref<IPConn>
	export function refOfIPConn(x:IPConn,v:Ref<IPConn>)
	export function unRefIPConn(v:Ref<IPConn>):IPConn
	export function emptyIPNet():IPNet
	export function emptyRefIPNet():Ref<IPNet>
	export function refOfIPNet(x:IPNet,v:Ref<IPNet>)
	export function unRefIPNet(v:Ref<IPNet>):IPNet
	export function emptyListenConfig():ListenConfig
	export function emptyRefListenConfig():Ref<ListenConfig>
	export function refOfListenConfig(x:ListenConfig,v:Ref<ListenConfig>)
	export function unRefListenConfig(v:Ref<ListenConfig>):ListenConfig
	export function emptyResolver():Resolver
	export function emptyRefResolver():Ref<Resolver>
	export function refOfResolver(x:Resolver,v:Ref<Resolver>)
	export function unRefResolver(v:Ref<Resolver>):Resolver
	export function emptySRV():SRV
	export function emptyRefSRV():Ref<SRV>
	export function refOfSRV(x:SRV,v:Ref<SRV>)
	export function unRefSRV(v:Ref<SRV>):SRV
	export function emptyUDPConn():UDPConn
	export function emptyRefUDPConn():Ref<UDPConn>
	export function refOfUDPConn(x:UDPConn,v:Ref<UDPConn>)
	export function unRefUDPConn(v:Ref<UDPConn>):UDPConn
	export function emptyDialer():Dialer
	export function emptyRefDialer():Ref<Dialer>
	export function refOfDialer(x:Dialer,v:Ref<Dialer>)
	export function unRefDialer(v:Ref<Dialer>):Dialer
	export function emptyIPAddr():IPAddr
	export function emptyRefIPAddr():Ref<IPAddr>
	export function refOfIPAddr(x:IPAddr,v:Ref<IPAddr>)
	export function unRefIPAddr(v:Ref<IPAddr>):IPAddr
	export function emptyUnixConn():UnixConn
	export function emptyRefUnixConn():Ref<UnixConn>
	export function refOfUnixConn(x:UnixConn,v:Ref<UnixConn>)
	export function unRefUnixConn(v:Ref<UnixConn>):UnixConn
}
