// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/image'{

	// @ts-ignore
	import * as color from 'golang/image/color'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import type {GoError,uint8,uint32,int,Struct,bool,Ref,error} from 'go'
	export interface Alpha extends Struct<Alpha>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			alphaAt(x:int,y:int):color.Alpha
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setAlpha(x:int,y:int,c:color.Alpha):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface Alpha16 extends Struct<Alpha16>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			alpha16At(x:int,y:int):color.Alpha16
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setAlpha16(x:int,y:int,c:color.Alpha16):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export const Black:Ref<Uniform>
	export interface CMYK extends Struct<CMYK>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			cmykAt(x:int,y:int):color.CMYK
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setCMYK(x:int,y:int,c:color.CMYK):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface Config extends Struct<Config>{

			colorModel:color.Model
			width:int
			height:int
	}
	export function decode(r:io.Reader):[Image,string]

	export function decodeConfig(r:io.Reader):[Config,string]

	export const ErrFormat:GoError
	export interface Gray extends Struct<Gray>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			grayAt(x:int,y:int):color.Gray
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setGray(x:int,y:int,c:color.Gray):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface Gray16 extends Struct<Gray16>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			gray16At(x:int,y:int):color.Gray16
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setGray16(x:int,y:int,c:color.Gray16):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface Image{

			at(x:int,y:int):color.Color
			bounds():Rectangle
			colorModel():color.Model
	}
	export interface NRGBA extends Struct<NRGBA>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			nrgbaAt(x:int,y:int):color.NRGBA
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setNRGBA(x:int,y:int,c:color.NRGBA):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface NRGBA64 extends Struct<NRGBA64>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			nrgbA64At(x:int,y:int):color.NRGBA64
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setNRGBA64(x:int,y:int,c:color.NRGBA64):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface NYCbCrA extends Struct<NYCbCrA>,RGBA64Image{

			yCbCr:YCbCr
			A:Uint8Array
			aStride:int
			colorModel():color.Model
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			nyCbCrAAt(x:int,y:int):color.NYCbCrA
			aOffset(x:int,y:int):int
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export function newAlpha(r:Rectangle):Ref<Alpha>

	export function newAlpha16(r:Rectangle):Ref<Alpha16>

	export function newCMYK(r:Rectangle):Ref<CMYK>

	export function newGray(r:Rectangle):Ref<Gray>

	export function newGray16(r:Rectangle):Ref<Gray16>

	export function newNRGBA(r:Rectangle):Ref<NRGBA>

	export function newNRGBA64(r:Rectangle):Ref<NRGBA64>

	export function newNYCbCrA(r:Rectangle,subsampleRatio:YCbCrSubsampleRatio):Ref<NYCbCrA>

	export function newPaletted(r:Rectangle,p:color.Palette):Ref<Paletted>

	export function newRGBA(r:Rectangle):Ref<RGBA>

	export function newRGBA64(r:Rectangle):Ref<RGBA64>

	export function newUniform(c:color.Color):Ref<Uniform>

	export function newYCbCr(r:Rectangle,subsampleRatio:YCbCrSubsampleRatio):Ref<YCbCr>

	export const Opaque:Ref<Uniform>
	export interface Paletted extends RGBA64Image,Struct<Paletted>,PalettedImage{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			palette:color.Palette
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			colorIndexAt(x:int,y:int):uint8
			setColorIndex(x:int,y:int,index:uint8):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface PalettedImage extends Image{

			colorIndexAt(x:int,y:int):uint8
	}
	export interface Point extends Struct<Point>{

			X:int
			Y:int
			string():string
			add(q:Point):Point
			sub(q:Point):Point
			mul(k:int):Point
			div(k:int):Point
			In(r:Rectangle):bool
			mod(r:Rectangle):Point
			eq(q:Point):bool
	}
	export function pt(X:int,Y:int):Point

	export interface RGBA extends Struct<RGBA>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			rgbaAt(x:int,y:int):color.RGBA
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			setRGBA(x:int,y:int,c:color.RGBA):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface RGBA64 extends Struct<RGBA64>,RGBA64Image{

			pix:Uint8Array
			stride:int
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			pixOffset(x:int,y:int):int
			set(x:int,y:int,c:color.Color):void
			setRGBA64(x:int,y:int,c:color.RGBA64):void
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface RGBA64Image extends Image{

			rgbA64At(x:int,y:int):color.RGBA64
	}
	export function rect(x0:int,y0:int,x1:int,y1:int):Rectangle

	export interface Rectangle extends Struct<Rectangle>,RGBA64Image{

			min:Point
			max:Point
			string():string
			dx():int
			dy():int
			size():Point
			add(p:Point):Rectangle
			sub(p:Point):Rectangle
			inset(n:int):Rectangle
			intersect(s:Rectangle):Rectangle
			union(s:Rectangle):Rectangle
			empty():bool
			eq(s:Rectangle):bool
			overlaps(s:Rectangle):bool
			In(s:Rectangle):bool
			canon():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			bounds():Rectangle
			colorModel():color.Model
	}
	export function registerFormat(name:string,magic:string,v2:(v1:io.Reader)=>Image,v1:(v1:io.Reader)=>Config):void

	export const Transparent:Ref<Uniform>
	export interface Uniform extends color.Model,RGBA64Image,Struct<Uniform>,color.Color{

			C:color.Color
			rgba():[uint32,uint32,uint32,uint32]
			colorModel():color.Model
			convert(v1:color.Color):color.Color
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			opaque():bool
	}
	export const White:Ref<Uniform>
	export interface YCbCr extends Struct<YCbCr>,RGBA64Image{

			Y:Uint8Array
			cb:Uint8Array
			cr:Uint8Array
			yStride:int
			cStride:int
			subsampleRatio:YCbCrSubsampleRatio
			rect:Rectangle
			colorModel():color.Model
			bounds():Rectangle
			at(x:int,y:int):color.Color
			rgbA64At(x:int,y:int):color.RGBA64
			yCbCrAt(x:int,y:int):color.YCbCr
			yOffset(x:int,y:int):int
			cOffset(x:int,y:int):int
			subImage(r:Rectangle):Image
			opaque():bool
	}
	export interface YCbCrSubsampleRatio extends int{

	string():string
	}
	export const YCbCrSubsampleRatio410:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio411:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio420:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio422:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio440:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio444:YCbCrSubsampleRatio
	export const ZP:Point
	export const ZR:Rectangle
	export function emptyPoint():Point
	export function emptyRefPoint():Ref<Point>
	export function refOfPoint(x:Point,v:Ref<Point>)
	export function unRefPoint(v:Ref<Point>):Point
	export function emptyConfig():Config
	export function emptyRefConfig():Ref<Config>
	export function refOfConfig(x:Config,v:Ref<Config>)
	export function unRefConfig(v:Ref<Config>):Config
	export function emptyRectangle():Rectangle
	export function emptyRefRectangle():Ref<Rectangle>
	export function refOfRectangle(x:Rectangle,v:Ref<Rectangle>)
	export function unRefRectangle(v:Ref<Rectangle>):Rectangle
}