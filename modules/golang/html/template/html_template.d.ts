// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/html/template'{

	// @ts-ignore
	import * as parse from 'golang/text/template/parse'
	// @ts-ignore
	import * as template from 'golang/text/template'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as fs from 'golang/io/fs'
	// @ts-ignore
	import * as json from 'golang/encoding/json'
	// @ts-ignore
	import type {GoError,bool,Ref,error,int,Struct} from 'go'
	export interface CSS extends string{

	}
	export const ErrAmbigContext:ErrorCode
	export const ErrBadHTML:ErrorCode
	export const ErrBranchEnd:ErrorCode
	export const ErrEndContext:ErrorCode
	export const ErrJSTemplate:ErrorCode
	export const ErrNoSuchTemplate:ErrorCode
	export const ErrOutputContext:ErrorCode
	export const ErrPartialCharset:ErrorCode
	export const ErrPartialEscape:ErrorCode
	export const ErrPredefinedEscaper:ErrorCode
	export const ErrRangeLoopReentry:ErrorCode
	export const ErrSlashAmbig:ErrorCode
	export interface Error extends Struct<Error>,Error,GoError{

			errorCode:ErrorCode
			node:parse.Node
			name:string
			line:int
			description:string
			error():string
	}
	export interface ErrorCode extends int{

	}
	export type FuncMap=template.FuncMap
	export interface HTML extends string{

	}
	export interface HTMLAttr extends string{

	}
	export function htmlEscape(w:io.Writer,b:Uint8Array):void

	export function htmlEscapeString(s:string):string

	export function htmlEscaper(...args:any[]):string

	export function isTrue(val:any):[bool,bool]

	export interface JS extends string{

	}
	export function jsEscape(w:io.Writer,b:Uint8Array):void

	export function jsEscapeString(s:string):string

	export function jsEscaper(...args:any[]):string

	export interface JSStr extends string{

	}
	export function must(t:Ref<Template>,err:error):Ref<Template>

	export function New(name:string):Ref<Template>

	export const OK:ErrorCode
	export function parseFS(fs:fs.FS,...patterns:string[]):Ref<Template>

	export function parseFiles(...filenames:string[]):Ref<Template>

	export function parseGlob(pattern:string):Ref<Template>

	export interface Srcset extends string{

	}
	export interface Template extends Struct<Template>,json.Token{

			tree:Ref<parse.Tree>
			templates():Ref<Template>[]
			option(...opt:string[]):Ref<Template>
			execute(wr:io.Writer,data:any)/*error*/
			executeTemplate(wr:io.Writer,name:string,data:any)/*error*/
			definedTemplates():string
			parse(text:string):Ref<Template>
			addParseTree(name:string,tree:Ref<parse.Tree>):Ref<Template>
			clone():Ref<Template>
			New(name:string):Ref<Template>
			name():string
			funcs(funcMap:template.FuncMap):Ref<Template>
			delims(left:string,right:string):Ref<Template>
			lookup(name:string):Ref<Template>
			parseFiles(...filenames:string[]):Ref<Template>
			parseGlob(pattern:string):Ref<Template>
			parseFS(fs:fs.FS,...patterns:string[]):Ref<Template>
	}
	export interface URL extends string{

	}
	export function urlQueryEscaper(...args:any[]):string

	export function emptyTemplate():Template
	export function emptyRefTemplate():Ref<Template>
	export function refOfTemplate(x:Template,v:Ref<Template>)
	export function unRefTemplate(v:Ref<Template>):Template
}