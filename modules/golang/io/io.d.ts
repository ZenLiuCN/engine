// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/io'{

	// @ts-ignore
	import type {byte,error,int64,GoError,Struct,int,Ref,rune} from 'go'
	export interface ByteReader{

			readByte():byte
	}
	export interface ByteScanner extends ByteReader{

			unreadByte()/*error*/
	}
	export interface ByteWriter{

			writeByte(c:byte)/*error*/
	}
	export interface Closer{

			close():error
	}
	export function copy(dst:Writer,src:Reader):int64

	export function copyBuffer(dst:Writer,src:Reader,buf:Uint8Array):int64

	export function copyN(dst:Writer,src:Reader,n:int64):int64

	export const Discard:Writer
	export const EOF:GoError
	export const ErrClosedPipe:GoError
	export const ErrNoProgress:GoError
	export const ErrShortBuffer:GoError
	export const ErrShortWrite:GoError
	export const ErrUnexpectedEOF:GoError
	export function limitReader(r:Reader,n:int64):Reader

	export interface LimitedReader extends Struct<LimitedReader>,Reader{

			R:Reader
			N:int64
			read(p:Uint8Array):int
	}
	export function multiReader(...readers:Reader[]):Reader

	export function multiWriter(...writers:Writer[]):Writer

	export function newOffsetWriter(w:WriterAt,off:int64):Ref<OffsetWriter>

	export function newSectionReader(r:ReaderAt,off:int64,n:int64):Ref<SectionReader>

	export function nopCloser(r:Reader):ReadCloser

	export interface OffsetWriter extends Struct<OffsetWriter>,WriterAt,WriteSeeker{

			write(p:Uint8Array):int
			writeAt(p:Uint8Array,off:int64):int
			seek(offset:int64,whence:int):int64
	}
	export function pipe():[Ref<PipeReader>,Ref<PipeWriter>]

	export interface PipeReader extends Struct<PipeReader>,ReadCloser,Closer{

			read(data:Uint8Array):int
			close():error
			closeWithError(err:error)/*error*/
	}
	export interface PipeWriter extends Struct<PipeWriter>,WriteCloser,Closer{

			write(data:Uint8Array):int
			close():error
			closeWithError(err:error)/*error*/
	}
	export function readAll(r:Reader):Uint8Array

	export function readAtLeast(r:Reader,buf:Uint8Array,min:int):int

	export interface ReadCloser extends Reader,Closer{

	}
	export function readFull(r:Reader,buf:Uint8Array):int

	export interface ReadSeekCloser extends Seeker,Closer,Reader{

	}
	export interface ReadSeeker extends Reader,Seeker{

	}
	export interface ReadWriteCloser extends Reader,Writer,Closer{

	}
	export interface ReadWriteSeeker extends Seeker,Reader,Writer{

	}
	export interface ReadWriter extends Reader,Writer{

	}
	export interface Reader{

			read(p:Uint8Array):int
	}
	export interface ReaderAt{

			readAt(p:Uint8Array,off:int64):int
	}
	export interface ReaderFrom{

			readFrom(r:Reader):int64
	}
	export interface RuneReader{

			readRune():[rune,int]
	}
	export interface RuneScanner extends RuneReader{

			unreadRune()/*error*/
	}
	export interface SectionReader extends Struct<SectionReader>,ReaderAt,ReadSeeker{

			read(p:Uint8Array):int
			seek(offset:int64,whence:int):int64
			readAt(p:Uint8Array,off:int64):int
			size():int64
	}
	//1
	export const SeekCurrent:int
	//2
	export const SeekEnd:int
	//0
	export const SeekStart:int
	export interface Seeker{

			seek(offset:int64,whence:int):int64
	}
	export interface StringWriter{

			writeString(s:string):int
	}
	export function teeReader(r:Reader,w:Writer):Reader

	export interface WriteCloser extends Writer,Closer{

	}
	export interface WriteSeeker extends Writer,Seeker{

	}
	export function writeString(w:Writer,s:string):int

	export interface Writer{

			write(p:Uint8Array):int
	}
	export interface WriterAt{

			writeAt(p:Uint8Array,off:int64):int
	}
	export interface WriterTo{

			writeTo(w:Writer):int64
	}
	export function emptyLimitedReader():LimitedReader
	export function emptyRefLimitedReader():Ref<LimitedReader>
	export function refOfLimitedReader(x:LimitedReader,v:Ref<LimitedReader>)
	export function unRefLimitedReader(v:Ref<LimitedReader>):LimitedReader
	export function emptyPipeReader():PipeReader
	export function emptyRefPipeReader():Ref<PipeReader>
	export function refOfPipeReader(x:PipeReader,v:Ref<PipeReader>)
	export function unRefPipeReader(v:Ref<PipeReader>):PipeReader
	export function emptyPipeWriter():PipeWriter
	export function emptyRefPipeWriter():Ref<PipeWriter>
	export function refOfPipeWriter(x:PipeWriter,v:Ref<PipeWriter>)
	export function unRefPipeWriter(v:Ref<PipeWriter>):PipeWriter
}