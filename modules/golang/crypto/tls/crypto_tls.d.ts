// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/crypto/tls'{

	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import * as net from 'golang/net'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as crypto from 'golang/crypto'
	// @ts-ignore
	import * as x509 from 'golang/crypto/x509'
	// @ts-ignore
	import type {GoError,int,error,bool,map,byte,uint8,Ref,Struct,uint16} from 'go'
	export interface AlertError extends uint8,GoError{

	error():string
	}
	export interface Certificate extends Struct<Certificate>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{

			certificate:Uint8Array[]
			privateKey:crypto.PrivateKey
			supportedSignatureAlgorithms:SignatureScheme[]
			ocspStaple:Uint8Array
			signedCertificateTimestamps:Uint8Array[]
			leaf:Ref<x509.Certificate>
	}
	export interface CertificateRequestInfo extends Struct<CertificateRequestInfo>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{

			acceptableCAs:Uint8Array[]
			signatureSchemes:SignatureScheme[]
			version:uint16
			context():context.Context
			supportsCertificate(c:Ref<Certificate>)/*error*/
	}
	export interface CertificateVerificationError extends GoError,Struct<CertificateVerificationError>,Error{

			unverifiedCertificates:Ref<x509.Certificate>[]
			err:GoError
			error():string
			unwrap()/*error*/
	}
	export interface CipherSuite extends crypto.PublicKey,crypto.PrivateKey,Struct<CipherSuite>,crypto.DecrypterOpts{

			id:uint16
			name:string
			supportedVersions:Uint16Array
			insecure:bool
	}
	export function cipherSuiteName(id:uint16):string

	export function cipherSuites():Ref<CipherSuite>[]

	export function client(conn:net.Conn,config:Ref<Config>):Ref<Conn>

	export interface ClientAuthType extends int{

	string():string
	}
	export interface ClientHelloInfo extends crypto.PrivateKey,Struct<ClientHelloInfo>,crypto.DecrypterOpts,crypto.PublicKey{

			cipherSuites:Uint16Array
			serverName:string
			supportedCurves:CurveID[]
			supportedPoints:Uint8Array
			signatureSchemes:SignatureScheme[]
			supportedProtos:string[]
			supportedVersions:Uint16Array
			conn:net.Conn
			context():context.Context
			supportsCertificate(c:Ref<Certificate>)/*error*/
	}
	export interface ClientSessionCache{

			get(sessionKey:string):[Ref<ClientSessionState>,bool]
			put(sessionKey:string,cs:Ref<ClientSessionState>):void
	}
	export interface ClientSessionState extends crypto.PublicKey,crypto.PrivateKey,Struct<ClientSessionState>,crypto.DecrypterOpts{

			resumptionState():[Uint8Array,Ref<SessionState>]
	}
	export interface Config extends Struct<Config>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey{

			rand:io.Reader
			time:()=>time.Time
			certificates:Certificate[]
			nameToCertificate:map<string,Ref<Certificate>>
			getCertificate:(v1:Ref<ClientHelloInfo>)=>Ref<Certificate>
			getClientCertificate:(v1:Ref<CertificateRequestInfo>)=>Ref<Certificate>
			getConfigForClient:(v1:Ref<ClientHelloInfo>)=>Ref<Config>
			verifyPeerCertificate:(rawCerts:Uint8Array[],verifiedChains:Ref<x509.Certificate>[][])=>void/*error*/
			verifyConnection:(v1:ConnectionState)=>void/*error*/
			rootCAs:Ref<x509.CertPool>
			nextProtos:string[]
			serverName:string
			clientAuth:ClientAuthType
			clientCAs:Ref<x509.CertPool>
			insecureSkipVerify:bool
			cipherSuites:Uint16Array
			preferServerCipherSuites:bool
			sessionTicketsDisabled:bool
			sessionTicketKey:byte/*32*/
			clientSessionCache:ClientSessionCache
			unwrapSession:(identity:Uint8Array,cs:ConnectionState)=>Ref<SessionState>
			wrapSession:(v2:ConnectionState,v1:Ref<SessionState>)=>Uint8Array
			minVersion:uint16
			maxVersion:uint16
			curvePreferences:CurveID[]
			dynamicRecordSizingDisabled:bool
			renegotiation:RenegotiationSupport
			keyLogWriter:io.Writer
			clone():Ref<Config>
			setSessionTicketKeys(keys:byte/*32*/[]):void
			buildNameToCertificate():void
			encryptTicket(cs:ConnectionState,ss:Ref<SessionState>):Uint8Array
			decryptTicket(identity:Uint8Array,cs:ConnectionState):Ref<SessionState>
	}
	export interface Conn extends crypto.PublicKey,io.Closer,io.ReadCloser,crypto.PrivateKey,io.ReadWriteCloser,Struct<Conn>,io.ReadWriter,crypto.DecrypterOpts,io.WriteCloser,net.Conn{

			localAddr():net.Addr
			remoteAddr():net.Addr
			setDeadline(t:time.Time)/*error*/
			setReadDeadline(t:time.Time)/*error*/
			setWriteDeadline(t:time.Time)/*error*/
			netConn():net.Conn
			write(b:Uint8Array):int
			read(b:Uint8Array):int
			close():error
			closeWrite()/*error*/
			handshake()/*error*/
			handshakeContext(ctx:context.Context)/*error*/
			connectionState():ConnectionState
			ocspResponse():Uint8Array
			verifyHostname(host:string)/*error*/
	}
	export interface ConnectionState extends crypto.PrivateKey,Struct<ConnectionState>,crypto.DecrypterOpts,crypto.PublicKey{

			version:uint16
			handshakeComplete:bool
			didResume:bool
			cipherSuite:uint16
			negotiatedProtocol:string
			negotiatedProtocolIsMutual:bool
			serverName:string
			peerCertificates:Ref<x509.Certificate>[]
			verifiedChains:Ref<x509.Certificate>[][]
			signedCertificateTimestamps:Uint8Array[]
			ocspResponse:Uint8Array
			tlsUnique:Uint8Array
			exportKeyingMaterial(label:string,context:Uint8Array,length:int):Uint8Array
	}
	export interface CurveID extends uint16{

	string():string
	}
	export const CurveP256:CurveID
	export const CurveP384:CurveID
	export const CurveP521:CurveID
	export function dial(network:string,addr:string,config:Ref<Config>):Ref<Conn>

	export function dialWithDialer(dialer:Ref<net.Dialer>,network:string,addr:string,config:Ref<Config>):Ref<Conn>

	export interface Dialer extends Struct<Dialer>,crypto.DecrypterOpts,crypto.PrivateKey,crypto.PublicKey{

			netDialer:Ref<net.Dialer>
			config:Ref<Config>
			dial(network:string,addr:string):net.Conn
			dialContext(ctx:context.Context,network:string,addr:string):net.Conn
	}
	export const ECDSAWithP256AndSHA256:SignatureScheme
	export const ECDSAWithP384AndSHA384:SignatureScheme
	export const ECDSAWithP521AndSHA512:SignatureScheme
	export const ECDSAWithSHA1:SignatureScheme
	export const Ed25519:SignatureScheme
	export function insecureCipherSuites():Ref<CipherSuite>[]

	export function listen(network:string,laddr:string,config:Ref<Config>):net.Listener

	export function loadX509KeyPair(certFile:string,keyFile:string):Certificate

	export function newLRUClientSessionCache(capacity:int):ClientSessionCache

	export function newListener(inner:net.Listener,config:Ref<Config>):net.Listener

	export function newResumptionState(ticket:Uint8Array,state:Ref<SessionState>):Ref<ClientSessionState>

	export const NoClientCert:ClientAuthType
	export const PKCS1WithSHA1:SignatureScheme
	export const PKCS1WithSHA256:SignatureScheme
	export const PKCS1WithSHA384:SignatureScheme
	export const PKCS1WithSHA512:SignatureScheme
	export const PSSWithSHA256:SignatureScheme
	export const PSSWithSHA384:SignatureScheme
	export const PSSWithSHA512:SignatureScheme
	export function parseSessionState(data:Uint8Array):Ref<SessionState>

	export function quicClient(config:Ref<QUICConfig>):Ref<QUICConn>

	export interface QUICConfig extends crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey,Struct<QUICConfig>{

			tlsConfig:Ref<Config>
	}
	export interface QUICConn extends crypto.PrivateKey,io.Closer,Struct<QUICConn>,crypto.DecrypterOpts,crypto.PublicKey{

			start(ctx:context.Context)/*error*/
			nextEvent():QUICEvent
			close():error
			handleData(level:QUICEncryptionLevel,data:Uint8Array)/*error*/
			sendSessionTicket(opts:QUICSessionTicketOptions)/*error*/
			connectionState():ConnectionState
			setTransportParameters(params:Uint8Array):void
	}
	export interface QUICEncryptionLevel extends int{

	string():string
	}
	export const QUICEncryptionLevelApplication:QUICEncryptionLevel
	export const QUICEncryptionLevelEarly:QUICEncryptionLevel
	export const QUICEncryptionLevelHandshake:QUICEncryptionLevel
	export const QUICEncryptionLevelInitial:QUICEncryptionLevel
	export interface QUICEvent extends Struct<QUICEvent>,crypto.PublicKey,crypto.DecrypterOpts,crypto.PrivateKey{

			kind:QUICEventKind
			level:QUICEncryptionLevel
			data:Uint8Array
			suite:uint16
	}
	export interface QUICEventKind extends int{

	}
	export const QUICHandshakeDone:QUICEventKind
	export const QUICNoEvent:QUICEventKind
	export const QUICRejectedEarlyData:QUICEventKind
	export function quicServer(config:Ref<QUICConfig>):Ref<QUICConn>

	export interface QUICSessionTicketOptions extends Struct<QUICSessionTicketOptions>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{

			earlyData:bool
	}
	export const QUICSetReadSecret:QUICEventKind
	export const QUICSetWriteSecret:QUICEventKind
	export const QUICTransportParameters:QUICEventKind
	export const QUICTransportParametersRequired:QUICEventKind
	export const QUICWriteData:QUICEventKind
	export interface RecordHeaderError extends Struct<RecordHeaderError>,Error,GoError{

			msg:string
			recordHeader:byte/*5*/
			conn:net.Conn
			error():string
	}
	export const RenegotiateFreelyAsClient:RenegotiationSupport
	export const RenegotiateNever:RenegotiationSupport
	export const RenegotiateOnceAsClient:RenegotiationSupport
	export interface RenegotiationSupport extends int{

	}
	export const RequestClientCert:ClientAuthType
	export const RequireAndVerifyClientCert:ClientAuthType
	export const RequireAnyClientCert:ClientAuthType
	export function server(conn:net.Conn,config:Ref<Config>):Ref<Conn>

	export interface SessionState extends Struct<SessionState>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey{

			extra:Uint8Array[]
			earlyData:bool
			bytes():Uint8Array
	}
	export interface SignatureScheme extends uint16{

	string():string
	}
	//4865
	export const TLS_AES_128_GCM_SHA256:uint16
	//4866
	export const TLS_AES_256_GCM_SHA384:uint16
	//4867
	export const TLS_CHACHA20_POLY1305_SHA256:uint16
	//49161
	export const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:uint16
	//49187
	export const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:uint16
	//49195
	export const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:uint16
	//49162
	export const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:uint16
	//49196
	export const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:uint16
	//52393
	export const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305:uint16
	//52393
	export const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:uint16
	//49159
	export const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:uint16
	//49170
	export const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:uint16
	//49171
	export const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:uint16
	//49191
	export const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:uint16
	//49199
	export const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:uint16
	//49172
	export const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:uint16
	//49200
	export const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:uint16
	//52392
	export const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305:uint16
	//52392
	export const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:uint16
	//49169
	export const TLS_ECDHE_RSA_WITH_RC4_128_SHA:uint16
	//22016
	export const TLS_FALLBACK_SCSV:uint16
	//10
	export const TLS_RSA_WITH_3DES_EDE_CBC_SHA:uint16
	//47
	export const TLS_RSA_WITH_AES_128_CBC_SHA:uint16
	//60
	export const TLS_RSA_WITH_AES_128_CBC_SHA256:uint16
	//156
	export const TLS_RSA_WITH_AES_128_GCM_SHA256:uint16
	//53
	export const TLS_RSA_WITH_AES_256_CBC_SHA:uint16
	//157
	export const TLS_RSA_WITH_AES_256_GCM_SHA384:uint16
	//5
	export const TLS_RSA_WITH_RC4_128_SHA:uint16
	export const VerifyClientCertIfGiven:ClientAuthType
	export function versionName(version:uint16):string

	//768
	export const VersionSSL30:int
	//769
	export const VersionTLS10:int
	//770
	export const VersionTLS11:int
	//771
	export const VersionTLS12:int
	//772
	export const VersionTLS13:int
	export const X25519:CurveID
	export function x509KeyPair(certPEMBlock:Uint8Array,keyPEMBlock:Uint8Array):Certificate

	export function emptyDialer():Dialer
	export function emptyRefDialer():Ref<Dialer>
	export function refOfDialer(x:Dialer,v:Ref<Dialer>)
	export function unRefDialer(v:Ref<Dialer>):Dialer
	export function emptyCertificateRequestInfo():CertificateRequestInfo
	export function emptyRefCertificateRequestInfo():Ref<CertificateRequestInfo>
	export function refOfCertificateRequestInfo(x:CertificateRequestInfo,v:Ref<CertificateRequestInfo>)
	export function unRefCertificateRequestInfo(v:Ref<CertificateRequestInfo>):CertificateRequestInfo
	export function emptyQUICConfig():QUICConfig
	export function emptyRefQUICConfig():Ref<QUICConfig>
	export function refOfQUICConfig(x:QUICConfig,v:Ref<QUICConfig>)
	export function unRefQUICConfig(v:Ref<QUICConfig>):QUICConfig
	export function emptyQUICConn():QUICConn
	export function emptyRefQUICConn():Ref<QUICConn>
	export function refOfQUICConn(x:QUICConn,v:Ref<QUICConn>)
	export function unRefQUICConn(v:Ref<QUICConn>):QUICConn
	export function emptyQUICEvent():QUICEvent
	export function emptyRefQUICEvent():Ref<QUICEvent>
	export function refOfQUICEvent(x:QUICEvent,v:Ref<QUICEvent>)
	export function unRefQUICEvent(v:Ref<QUICEvent>):QUICEvent
	export function emptyQUICSessionTicketOptions():QUICSessionTicketOptions
	export function emptyRefQUICSessionTicketOptions():Ref<QUICSessionTicketOptions>
	export function refOfQUICSessionTicketOptions(x:QUICSessionTicketOptions,v:Ref<QUICSessionTicketOptions>)
	export function unRefQUICSessionTicketOptions(v:Ref<QUICSessionTicketOptions>):QUICSessionTicketOptions
	export function emptySessionState():SessionState
	export function emptyRefSessionState():Ref<SessionState>
	export function refOfSessionState(x:SessionState,v:Ref<SessionState>)
	export function unRefSessionState(v:Ref<SessionState>):SessionState
	export function emptyCertificate():Certificate
	export function emptyRefCertificate():Ref<Certificate>
	export function refOfCertificate(x:Certificate,v:Ref<Certificate>)
	export function unRefCertificate(v:Ref<Certificate>):Certificate
	export function emptyClientSessionState():ClientSessionState
	export function emptyRefClientSessionState():Ref<ClientSessionState>
	export function refOfClientSessionState(x:ClientSessionState,v:Ref<ClientSessionState>)
	export function unRefClientSessionState(v:Ref<ClientSessionState>):ClientSessionState
	export function emptyConnectionState():ConnectionState
	export function emptyRefConnectionState():Ref<ConnectionState>
	export function refOfConnectionState(x:ConnectionState,v:Ref<ConnectionState>)
	export function unRefConnectionState(v:Ref<ConnectionState>):ConnectionState
	export function emptyCipherSuite():CipherSuite
	export function emptyRefCipherSuite():Ref<CipherSuite>
	export function refOfCipherSuite(x:CipherSuite,v:Ref<CipherSuite>)
	export function unRefCipherSuite(v:Ref<CipherSuite>):CipherSuite
	export function emptyConfig():Config
	export function emptyRefConfig():Ref<Config>
	export function refOfConfig(x:Config,v:Ref<Config>)
	export function unRefConfig(v:Ref<Config>):Config
	export function emptyClientHelloInfo():ClientHelloInfo
	export function emptyRefClientHelloInfo():Ref<ClientHelloInfo>
	export function refOfClientHelloInfo(x:ClientHelloInfo,v:Ref<ClientHelloInfo>)
	export function unRefClientHelloInfo(v:Ref<ClientHelloInfo>):ClientHelloInfo
	export function emptyConn():Conn
	export function emptyRefConn():Ref<Conn>
	export function refOfConn(x:Conn,v:Ref<Conn>)
	export function unRefConn(v:Ref<Conn>):Conn
}