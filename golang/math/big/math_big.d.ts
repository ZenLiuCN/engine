// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/math/big'{
	// @ts-ignore
	import * as fmt from 'golang/fmt'
	// @ts-ignore
	import * as rand from 'golang/math/rand'
	// @ts-ignore
	import type {GoError,uint,uint64,int64,float64,int8,int,float32,byte,Struct,Ref,bool,error,rune} from 'go'
	export const Above:Accuracy
	export interface Accuracy extends int8{
		string():string
	}
	export const AwayFromZero:RoundingMode
	export const Below:Accuracy
	export interface ErrNaN extends GoError,Struct<ErrNaN>,Error{
		error():string
	}
	export const Exact:Accuracy
	export interface Float extends fmt.Stringer,fmt.Scanner,fmt.Formatter,Struct<Float>{
		setPrec(prec:uint):Ref<Float>
		setMode(mode:RoundingMode):Ref<Float>
		prec():uint
		minPrec():uint
		mode():RoundingMode
		acc():Accuracy
		sign():int
		mantExp(mant:Ref<Float>):int
		setMantExp(mant:Ref<Float>,exp:int):Ref<Float>
		signbit():bool
		isInf():bool
		isInt():bool
		setUint64(x:uint64):Ref<Float>
		setInt64(x:int64):Ref<Float>
		setFloat64(x:float64):Ref<Float>
		setInt(x:Ref<Int>):Ref<Float>
		setRat(x:Ref<Rat>):Ref<Float>
		setInf(signbit:bool):Ref<Float>
		set(x:Ref<Float>):Ref<Float>
		copy(x:Ref<Float>):Ref<Float>
		uint64():[uint64,Accuracy]
		int64():[int64,Accuracy]
		float32():[float32,Accuracy]
		float64():[float64,Accuracy]
		int(z:Ref<Int>):[Ref<Int>,Accuracy]
		rat(z:Ref<Rat>):[Ref<Rat>,Accuracy]
		abs(x:Ref<Float>):Ref<Float>
		neg(x:Ref<Float>):Ref<Float>
		add(x:Ref<Float>,y:Ref<Float>):Ref<Float>
		sub(x:Ref<Float>,y:Ref<Float>):Ref<Float>
		mul(x:Ref<Float>,y:Ref<Float>):Ref<Float>
		quo(x:Ref<Float>,y:Ref<Float>):Ref<Float>
		cmp(y:Ref<Float>):int
		setString(s:string):[Ref<Float>,bool]
		parse(s:string,base:int):[Ref<Float>,int,error]
		scan(s:fmt.ScanState,ch:rune):error
		gobEncode():[Uint8Array,error]
		gobDecode(buf:Uint8Array):error
		marshalText():[Uint8Array,error]
		unmarshalText(text:Uint8Array):error
		text(format:byte,prec:int):string
		string():string
		append(buf:Uint8Array,fmt:byte,prec:int):Uint8Array
		format(s:fmt.State,format:rune):void
		sqrt(x:Ref<Float>):Ref<Float>
	}
	export interface Int extends Struct<Int>,fmt.Scanner,fmt.Formatter,fmt.Stringer{
		sign():int
		setInt64(x:int64):Ref<Int>
		setUint64(x:uint64):Ref<Int>
		set(x:Ref<Int>):Ref<Int>
		bits():Word[]
		setBits(abs:Word[]):Ref<Int>
		abs(x:Ref<Int>):Ref<Int>
		neg(x:Ref<Int>):Ref<Int>
		add(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		sub(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		mul(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		mulRange(a:int64,b:int64):Ref<Int>
		binomial(n:int64,k:int64):Ref<Int>
		quo(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		rem(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		quoRem(x:Ref<Int>,y:Ref<Int>,r:Ref<Int>):[Ref<Int>,Ref<Int>]
		div(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		mod(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		divMod(x:Ref<Int>,y:Ref<Int>,m:Ref<Int>):[Ref<Int>,Ref<Int>]
		cmp(y:Ref<Int>):int
		cmpAbs(y:Ref<Int>):int
		int64():int64
		uint64():uint64
		isInt64():bool
		isUint64():bool
		float64():[float64,Accuracy]
		setString(s:string,base:int):[Ref<Int>,bool]
		setBytes(buf:Uint8Array):Ref<Int>
		bytes():Uint8Array
		fillBytes(buf:Uint8Array):Uint8Array
		bitLen():int
		trailingZeroBits():uint
		exp(x:Ref<Int>,y:Ref<Int>,m:Ref<Int>):Ref<Int>
		gcd(x:Ref<Int>,y:Ref<Int>,a:Ref<Int>,b:Ref<Int>):Ref<Int>
		rand(rnd:Ref<rand.Rand>,n:Ref<Int>):Ref<Int>
		modInverse(g:Ref<Int>,n:Ref<Int>):Ref<Int>
		modSqrt(x:Ref<Int>,p:Ref<Int>):Ref<Int>
		lsh(x:Ref<Int>,n:uint):Ref<Int>
		rsh(x:Ref<Int>,n:uint):Ref<Int>
		bit(i:int):uint
		setBit(x:Ref<Int>,i:int,b:uint):Ref<Int>
		and(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		andNot(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		or(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		xor(x:Ref<Int>,y:Ref<Int>):Ref<Int>
		not(x:Ref<Int>):Ref<Int>
		sqrt(x:Ref<Int>):Ref<Int>
		text(base:int):string
		append(buf:Uint8Array,base:int):Uint8Array
		string():string
		format(s:fmt.State,ch:rune):void
		scan(s:fmt.ScanState,ch:rune):error
		gobEncode():[Uint8Array,error]
		gobDecode(buf:Uint8Array):error
		marshalText():[Uint8Array,error]
		unmarshalText(text:Uint8Array):error
		marshalJSON():[Uint8Array,error]
		unmarshalJSON(text:Uint8Array):error
		probablyPrime(n:int):bool
	}
	export function jacobi(x:Ref<Int>,y:Ref<Int>):int
	//62
	export const MaxBase:rune
	//2147483647
	export const MaxExp:int
	//4294967295
	export const MaxPrec:int
	//-2147483648
	export const MinExp:int
	export function newFloat(x:float64):Ref<Float>
	export function newInt(x:int64):Ref<Int>
	export function newRat(a:int64,b:int64):Ref<Rat>
	export function parseFloat(s:string,base:int,prec:uint,mode:RoundingMode):[Ref<Float>,int,error]
	export interface Rat extends fmt.Stringer,fmt.Scanner,Struct<Rat>{
		setFloat64(f:float64):Ref<Rat>
		float32():[float32,bool]
		float64():[float64,bool]
		setFrac(a:Ref<Int>,b:Ref<Int>):Ref<Rat>
		setFrac64(a:int64,b:int64):Ref<Rat>
		setInt(x:Ref<Int>):Ref<Rat>
		setInt64(x:int64):Ref<Rat>
		setUint64(x:uint64):Ref<Rat>
		set(x:Ref<Rat>):Ref<Rat>
		abs(x:Ref<Rat>):Ref<Rat>
		neg(x:Ref<Rat>):Ref<Rat>
		inv(x:Ref<Rat>):Ref<Rat>
		sign():int
		isInt():bool
		num():Ref<Int>
		denom():Ref<Int>
		cmp(y:Ref<Rat>):int
		add(x:Ref<Rat>,y:Ref<Rat>):Ref<Rat>
		sub(x:Ref<Rat>,y:Ref<Rat>):Ref<Rat>
		mul(x:Ref<Rat>,y:Ref<Rat>):Ref<Rat>
		quo(x:Ref<Rat>,y:Ref<Rat>):Ref<Rat>
		scan(s:fmt.ScanState,ch:rune):error
		setString(s:string):[Ref<Rat>,bool]
		string():string
		ratString():string
		floatString(prec:int):string
		gobEncode():[Uint8Array,error]
		gobDecode(buf:Uint8Array):error
		marshalText():[Uint8Array,error]
		unmarshalText(text:Uint8Array):error
	}
	export interface RoundingMode extends byte{
		string():string
	}
	export const ToNearestAway:RoundingMode
	export const ToNearestEven:RoundingMode
	export const ToNegativeInf:RoundingMode
	export const ToPositiveInf:RoundingMode
	export const ToZero:RoundingMode
	export interface Word extends uint{
	}

export function emptyInt():Int
export function refInt():Ref<Int>
export function refOfInt(x:Int):Ref<Int>
export function emptyRat():Rat
export function refRat():Ref<Rat>
export function refOfRat(x:Rat):Ref<Rat>
export function emptyFloat():Float
export function refFloat():Ref<Float>
export function refOfFloat(x:Float):Ref<Float>}
