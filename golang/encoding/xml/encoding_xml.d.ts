// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/encoding/xml'{
	// @ts-ignore
	import * as reflect from 'golang/reflect'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import type {Ref,int64,int,GoError,Struct,bool,error} from 'go'
	export interface Attr extends Struct<Attr>,Token{
		name:Name
		value:string
	}
	export interface CharData extends Uint8Array{
		copy():CharData
	}
	export interface Comment extends Uint8Array{
		copy():Comment
	}
	export function copyToken(t:Token):Token
	export interface Decoder extends Struct<Decoder>,TokenReader,Token{
		strict:bool
		autoClose:string[]
		entity:Record<string,string>
		charsetReader:(charset:string,input:io.Reader)=>[io.Reader,error]
		defaultSpace:string
		decode(v:any):error
		decodeElement(v:any,start:Ref<StartElement>):error
		skip():error
		token():[Token,error]
		rawToken():[Token,error]
		inputOffset():int64
		inputPos():[int,int]
	}
	export interface Directive extends Uint8Array{
		copy():Directive
	}
	export interface Encoder extends Struct<Encoder>,io.Closer,Token{
		indent(prefix:string,indent:string):void
		encode(v:any):error
		encodeElement(v:any,start:StartElement):error
		encodeToken(t:Token):error
		flush():error
		close():error
	}
	export interface EndElement extends Token,Struct<EndElement>{
		name:Name
	}
	export function escape(w:io.Writer,s:Uint8Array):void
	export function escapeText(w:io.Writer,s:Uint8Array):error
	export const HTMLAutoClose:string[]
	export const HTMLEntity:Record<string,string>
	//"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
	export const Header:string
	export function marshal(v:any):Uint8Array
	export function marshalIndent(v:any,prefix:string,indent:string):[Uint8Array,error]
	export interface Marshaler{
		marshalXML(e:Ref<Encoder>,start:StartElement):error
	}
	export interface MarshalerAttr{
		marshalXMLAttr(name:Name):[Attr,error]
	}
	export interface Name extends Struct<Name>,Token{
		space:string
		local:string
	}
	export function newDecoder(r:io.Reader):Ref<Decoder>
	export function newEncoder(w:io.Writer):Ref<Encoder>
	export function newTokenDecoder(t:TokenReader):Ref<Decoder>
	export interface ProcInst extends Struct<ProcInst>,Token{
		target:string
		inst:Uint8Array
		copy():ProcInst
	}
	export interface StartElement extends Struct<StartElement>,Token{
		name:Name
		attr:Attr[]
		copy():StartElement
		end():EndElement
	}
	export interface SyntaxError extends Struct<SyntaxError>,Error,GoError{
		msg:string
		line:int
		error():string
	}
	export interface TagPathError extends Struct<TagPathError>,Error,GoError{
		struct:reflect.Type
		field1:string
		tag1:string
		field2:string
		tag2:string
		error():string
	}
	export interface Token{
	}
	export interface TokenReader{
		token():[Token,error]
	}
	export function unmarshal(data:Uint8Array,v:any):error
	export interface UnmarshalError extends string,GoError{
		error():string
	}
	export interface Unmarshaler{
		unmarshalXML(d:Ref<Decoder>,start:StartElement):error
	}
	export interface UnmarshalerAttr{
		unmarshalXMLAttr(attr:Attr):error
	}
	export interface UnsupportedTypeError extends Struct<UnsupportedTypeError>,Error,GoError{
		type:reflect.Type
		error():string
	}

export function emptyAttr():Attr
export function refAttr():Ref<Attr>
export function refOfAttr(x:Attr):Ref<Attr>
export function emptyEncoder():Encoder
export function refEncoder():Ref<Encoder>
export function refOfEncoder(x:Encoder):Ref<Encoder>
export function emptyName():Name
export function refName():Ref<Name>
export function refOfName(x:Name):Ref<Name>
export function emptyProcInst():ProcInst
export function refProcInst():Ref<ProcInst>
export function refOfProcInst(x:ProcInst):Ref<ProcInst>
export function emptyDecoder():Decoder
export function refDecoder():Ref<Decoder>
export function refOfDecoder(x:Decoder):Ref<Decoder>
export function emptyEndElement():EndElement
export function refEndElement():Ref<EndElement>
export function refOfEndElement(x:EndElement):Ref<EndElement>
export function emptyStartElement():StartElement
export function refStartElement():Ref<StartElement>
export function refOfStartElement(x:StartElement):Ref<StartElement>}
