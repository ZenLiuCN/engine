// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/encoding/xml'{
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as reflect from 'golang/reflect'
	// @ts-ignore
	import type {GoError,Struct,bool,error,Ref,int64,int} from 'go'
	export interface Attr extends Struct<Attr>,Token{
		name:Name
		value:string
	}
	export interface CharData extends Uint8Array{
		copy():CharData
	}
	export interface Comment extends Uint8Array{
		copy():Comment
	}
	export function copyToken(t:Token):Token
	export interface Decoder extends Struct<Decoder>,Token,TokenReader{
		strict:bool
		autoClose:string[]
		entity:Record<string,string>
		charsetReader:(charset:string,input:io.Reader)=>io.Reader
		defaultSpace:string
		decode(v:any)/*error*/
		decodeElement(v:any,start:Ref<StartElement>)/*error*/
		skip()/*error*/
		token():Token
		rawToken():Token
		inputOffset():int64
		inputPos():[int,int]
	}
	export interface Directive extends Uint8Array{
		copy():Directive
	}
	export interface Encoder extends Struct<Encoder>,io.Closer,Token{
		indent(prefix:string,indent:string):void
		encode(v:any)/*error*/
		encodeElement(v:any,start:StartElement)/*error*/
		encodeToken(t:Token)/*error*/
		flush()/*error*/
		close():error
	}
	export interface EndElement extends Struct<EndElement>,Token{
		name:Name
	}
	export function escape(w:io.Writer,s:Uint8Array):void
	export function escapeText(w:io.Writer,s:Uint8Array)/*error*/
	export const HTMLAutoClose:string[]
	export const HTMLEntity:Record<string,string>
	//"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
	export const Header:string
	export function marshal(v:any):Uint8Array
	export function marshalIndent(v:any,prefix:string,indent:string):Uint8Array
	export interface Marshaler{
		marshalXML(e:Ref<Encoder>,start:StartElement)/*error*/
	}
	export interface MarshalerAttr{
		marshalXMLAttr(name:Name):Attr
	}
	export interface Name extends Token,Struct<Name>{
		space:string
		local:string
	}
	export function newDecoder(r:io.Reader):Ref<Decoder>
	export function newEncoder(w:io.Writer):Ref<Encoder>
	export function newTokenDecoder(t:TokenReader):Ref<Decoder>
	export interface ProcInst extends Struct<ProcInst>,Token{
		target:string
		inst:Uint8Array
		copy():ProcInst
	}
	export interface StartElement extends Struct<StartElement>,Token{
		name:Name
		attr:Attr[]
		copy():StartElement
		end():EndElement
	}
	export interface SyntaxError extends GoError,Struct<SyntaxError>,Error{
		msg:string
		line:int
		error():string
	}
	export interface TagPathError extends Struct<TagPathError>,Error,GoError{
		struct:reflect.Type
		field1:string
		tag1:string
		field2:string
		tag2:string
		error():string
	}
	export interface Token{
	}
	export interface TokenReader{
		token():Token
	}
	export function unmarshal(data:Uint8Array,v:any)/*error*/
	export interface UnmarshalError extends string,GoError{
		error():string
	}
	export interface Unmarshaler{
		unmarshalXML(d:Ref<Decoder>,start:StartElement)/*error*/
	}
	export interface UnmarshalerAttr{
		unmarshalXMLAttr(attr:Attr)/*error*/
	}
	export interface UnsupportedTypeError extends Struct<UnsupportedTypeError>,Error,GoError{
		type:reflect.Type
		error():string
	}

export function emptyDecoder():Decoder
export function refDecoder():Ref<Decoder>
export function refOfDecoder(x:Decoder):Ref<Decoder>
export function emptyEncoder():Encoder
export function refEncoder():Ref<Encoder>
export function refOfEncoder(x:Encoder):Ref<Encoder>
export function emptyProcInst():ProcInst
export function refProcInst():Ref<ProcInst>
export function refOfProcInst(x:ProcInst):Ref<ProcInst>
export function emptyStartElement():StartElement
export function refStartElement():Ref<StartElement>
export function refOfStartElement(x:StartElement):Ref<StartElement>
export function emptyAttr():Attr
export function refAttr():Ref<Attr>
export function refOfAttr(x:Attr):Ref<Attr>
export function emptyEndElement():EndElement
export function refEndElement():Ref<EndElement>
export function refOfEndElement(x:EndElement):Ref<EndElement>
export function emptyName():Name
export function refName():Ref<Name>
export function refOfName(x:Name):Ref<Name>
}
