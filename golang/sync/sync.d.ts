// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/sync'{
	// @ts-ignore
	import type {Struct,bool,Ref,int} from 'go'
	export interface Cond extends Struct<Cond>{
		L:Locker
		wait():void
		signal():void
		broadcast():void
	}
	export interface Locker{
		lock():void
		unlock():void
	}
	export interface Map extends Struct<Map>{
		load(key:any):[any,bool]
		store(key:any,value:any):void
		loadOrStore(key:any,value:any):[any,bool]
		loadAndDelete(key:any):[any,bool]
		delete(key:any):void
		swap(key:any,value:any):[any,bool]
		compareAndSwap(key:any,old:any,New:any):bool
		compareAndDelete(key:any,old:any):bool
		range(f:(key:any,value:any)=>bool):void
	}
	export interface Mutex extends Struct<Mutex>,Locker{
		lock():void
		tryLock():bool
		unlock():void
	}
	export function newCond(l:Locker):Ref<Cond>
	export interface Once extends Struct<Once>{
		Do(f:()=>void):void
	}
	export function onceFunc(f:()=>void):()=>void
	export interface Pool extends Struct<Pool>{
		New:()=>any
		put(x:any):void
		get():any
	}
	export interface RWMutex extends Locker,Struct<RWMutex>{
		rLock():void
		tryRLock():bool
		rUnlock():void
		lock():void
		tryLock():bool
		unlock():void
		rLocker():Locker
	}
	export interface WaitGroup extends Struct<WaitGroup>{
		add(delta:int):void
		done():void
		wait():void
	}

export function emptyMap():Map
export function refMap():Ref<Map>
export function refOfMap(x:Map):Ref<Map>
export function emptyMutex():Mutex
export function refMutex():Ref<Mutex>
export function refOfMutex(x:Mutex):Ref<Mutex>
export function emptyOnce():Once
export function refOnce():Ref<Once>
export function refOfOnce(x:Once):Ref<Once>
export function emptyPool():Pool
export function refPool():Ref<Pool>
export function refOfPool(x:Pool):Ref<Pool>
export function emptyRWMutex():RWMutex
export function refRWMutex():Ref<RWMutex>
export function refOfRWMutex(x:RWMutex):Ref<RWMutex>
export function emptyWaitGroup():WaitGroup
export function refWaitGroup():Ref<WaitGroup>
export function refOfWaitGroup(x:WaitGroup):Ref<WaitGroup>
export function emptyCond():Cond
export function refCond():Ref<Cond>
export function refOfCond(x:Cond):Ref<Cond>
}
