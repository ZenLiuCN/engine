// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/regexp/syntax'{
	// @ts-ignore
	import type {GoError,uint16,uint32,int,rune,error,uint8,Struct,bool,Ref} from 'go'
	export const ClassNL:Flags
	export function compile(re:Ref<Regexp>):Ref<Prog>
	export const DotNL:Flags
	export const EmptyBeginLine:EmptyOp
	export const EmptyBeginText:EmptyOp
	export const EmptyEndLine:EmptyOp
	export const EmptyEndText:EmptyOp
	export const EmptyNoWordBoundary:EmptyOp
	export interface EmptyOp extends uint8{
	}
	export function emptyOpContext(r1:rune,r2:rune):EmptyOp
	export const EmptyWordBoundary:EmptyOp
	export const ErrInternalError:ErrorCode
	export const ErrInvalidCharClass:ErrorCode
	export const ErrInvalidCharRange:ErrorCode
	export const ErrInvalidEscape:ErrorCode
	export const ErrInvalidNamedCapture:ErrorCode
	export const ErrInvalidPerlOp:ErrorCode
	export const ErrInvalidRepeatOp:ErrorCode
	export const ErrInvalidRepeatSize:ErrorCode
	export const ErrInvalidUTF8:ErrorCode
	export const ErrLarge:ErrorCode
	export const ErrMissingBracket:ErrorCode
	export const ErrMissingParen:ErrorCode
	export const ErrMissingRepeatArgument:ErrorCode
	export const ErrNestingDepth:ErrorCode
	export const ErrTrailingBackslash:ErrorCode
	export const ErrUnexpectedParen:ErrorCode
	export interface Error extends Struct<Error>,Error,GoError{
		code:ErrorCode
		expr:string
		error():string
	}
	export interface ErrorCode extends string{
		string():string
	}
	export interface Flags extends uint16{
	}
	export const FoldCase:Flags
	export interface Inst extends Struct<Inst>{
		op:InstOp
		out:uint32
		arg:uint32
		rune:rune[]
		matchRune(r:rune):bool
		matchRunePos(r:rune):int
		matchEmptyWidth(before:rune,after:rune):bool
		string():string
	}
	export const InstAlt:InstOp
	export const InstAltMatch:InstOp
	export const InstCapture:InstOp
	export const InstEmptyWidth:InstOp
	export const InstFail:InstOp
	export const InstMatch:InstOp
	export const InstNop:InstOp
	export interface InstOp extends uint8{
		string():string
	}
	export const InstRune:InstOp
	export const InstRune1:InstOp
	export const InstRuneAny:InstOp
	export const InstRuneAnyNotNL:InstOp
	export function isWordChar(r:rune):bool
	export const Literal:Flags
	export const MatchNL:Flags
	export const NonGreedy:Flags
	export const OneLine:Flags
	export interface Op extends uint8{
		string():string
	}
	export const OpAlternate:Op
	export const OpAnyChar:Op
	export const OpAnyCharNotNL:Op
	export const OpBeginLine:Op
	export const OpBeginText:Op
	export const OpCapture:Op
	export const OpCharClass:Op
	export const OpConcat:Op
	export const OpEmptyMatch:Op
	export const OpEndLine:Op
	export const OpEndText:Op
	export const OpLiteral:Op
	export const OpNoMatch:Op
	export const OpNoWordBoundary:Op
	export const OpPlus:Op
	export const OpQuest:Op
	export const OpRepeat:Op
	export const OpStar:Op
	export const OpWordBoundary:Op
	export const POSIX:Flags
	export function parse(s:string,flags:Flags):[Ref<Regexp>,error]
	export const Perl:Flags
	export const PerlX:Flags
	export interface Prog extends Struct<Prog>{
		inst:Inst[]
		start:int
		numCap:int
		string():string
		prefix():[string,bool]
		startCond():EmptyOp
	}
	export interface Regexp extends Struct<Regexp>{
		op:Op
		flags:Flags
		sub:Ref<Regexp>[]
		sub0:Ref<Regexp>[/*1*/]
		rune:rune[]
		rune0:rune[]/*2*/
		min:int
		max:int
		cap:int
		name:string
		equal(y:Ref<Regexp>):bool
		string():string
		maxCap():int
		capNames():string[]
		simplify():Ref<Regexp>
	}
	export const Simple:Flags
	export const UnicodeGroups:Flags
	export const WasDollar:Flags

export function emptyInst():Inst
export function refInst():Ref<Inst>
export function refOfInst(x:Inst):Ref<Inst>
export function emptyProg():Prog
export function refProg():Ref<Prog>
export function refOfProg(x:Prog):Ref<Prog>
export function emptyRegexp():Regexp
export function refRegexp():Ref<Regexp>
export function refOfRegexp(x:Regexp):Ref<Regexp>}
