// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/net/http'{
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as go from 'go'
	// @ts-ignore
	import * as fmt from 'golang/fmt'
	// @ts-ignore
	import * as fs from 'golang/io/fs'
	// @ts-ignore
	import * as bufio from 'golang/bufio'
	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import * as tls from 'golang/crypto/tls'
	// @ts-ignore
	import * as log from 'golang/log'
	// @ts-ignore
	import * as url from 'golang/net/url'
	// @ts-ignore
	import * as net from 'golang/net'
	// @ts-ignore
	import * as multipart from 'golang/mime/multipart'
	// @ts-ignore
	import type {Ref,GoError,Alias,error,Struct,bool,int,int64,Nothing} from 'go'
	export function allowQuerySemicolons(h:Handler):Handler
	export function canonicalHeaderKey(s:string):string
	export interface Client extends Struct<Client>{
		transport:RoundTripper
		checkRedirect:(req:Ref<Request>,via:Ref<Request>[])=>error
		jar:CookieJar
		timeout:time.Duration
		get(url:string):[Ref<Response>,error]
		Do(req:Ref<Request>):[Ref<Response>,error]
		post(url:string,contentType:string,body:io.Reader):[Ref<Response>,error]
		postForm(url:string,data:url.Values):[Ref<Response>,error]
		head(url:string):[Ref<Response>,error]
		closeIdleConnections():void
	}
	export interface CloseNotifier{
		closeNotify():go.ChanRecv<bool>
	}
	export interface ConnState extends int{
		string():string
	}
	export interface Cookie extends Struct<Cookie>,fmt.Stringer{
		name:string
		value:string
		path:string
		domain:string
		expires:time.Time
		rawExpires:string
		maxAge:int
		secure:bool
		httpOnly:bool
		sameSite:SameSite
		raw:string
		unparsed:string[]
		string():string
		valid():error
	}
	export interface CookieJar{
		cookies(u:Ref<url.URL>):Ref<Cookie>[]
		setCookies(u:Ref<url.URL>,cookies:Ref<Cookie>[]):void
	}
	export const DefaultClient:Ref<Client>
	//1048576
	export const DefaultMaxHeaderBytes:int
	//2
	export const DefaultMaxIdleConnsPerHost:int
	export const DefaultServeMux:Ref<ServeMux>
	export const DefaultTransport:RoundTripper
	export function detectContentType(data:Uint8Array):string
	export interface Dir extends string{
		open(name:string):[File,error]
	}
	export const ErrAbortHandler:GoError
	export const ErrBodyNotAllowed:GoError
	export const ErrBodyReadAfterClose:GoError
	export const ErrContentLength:GoError
	export const ErrHandlerTimeout:GoError
	export const ErrHeaderTooLong:Ref<ProtocolError>
	export const ErrHijacked:GoError
	export const ErrLineTooLong:GoError
	export const ErrMissingBoundary:Ref<ProtocolError>
	export const ErrMissingContentLength:Ref<ProtocolError>
	export const ErrMissingFile:GoError
	export const ErrNoCookie:GoError
	export const ErrNoLocation:GoError
	export const ErrNotMultipart:Ref<ProtocolError>
	export const ErrNotSupported:Ref<ProtocolError>
	export const ErrSchemeMismatch:GoError
	export const ErrServerClosed:GoError
	export const ErrShortBody:Ref<ProtocolError>
	export const ErrSkipAltProtocol:GoError
	export const ErrUnexpectedTrailer:Ref<ProtocolError>
	export const ErrUseLastResponse:GoError
	export const ErrWriteAfterFlush:GoError
	export function error(w:ResponseWriter,error:string,code:int):void
	export function fs(fsys:fs.FS):FileSystem
	export interface File extends io.Closer,io.Reader,io.Seeker{
		readdir(count:int):[fs.FileInfo[],error]
		stat():[fs.FileInfo,error]
	}
	export function fileServer(root:FileSystem):Handler
	export interface FileSystem{
		open(name:string):[File,error]
	}
	export interface Flusher{
		flush():void
	}
	export function get(url:string):Ref<Response>
	export function handle(pattern:string,handler:Handler):void
	export function handleFunc(pattern:string,handler:(v2:ResponseWriter,v1:Ref<Request>)=>void):void
	export interface Handler{
		serveHTTP(v2:ResponseWriter,v1:Ref<Request>):void
	}
	export interface HandlerFunc extends Alias<(v2:ResponseWriter,v1:Ref<Request>)=>void>{
		serveHTTP(w:ResponseWriter,r:Ref<Request>):void
	}
	export function head(url:string):Ref<Response>
	export interface Header extends Record<string,string[]>{
		add(key:string,value:string):void
		set(key:string,value:string):void
		get(key:string):string
		values(key:string):string[]
		del(key:string):void
		write(w:io.Writer):error
		clone():Header
		writeSubset(w:io.Writer,exclude:Record<string,bool>):error
	}
	export interface Hijacker{
		hijack():[net.Conn,Ref<bufio.ReadWriter>,error]
	}
	export function listenAndServe(addr:string,handler:Handler):error
	export function listenAndServeTLS(addr:string,certFile:string,keyFile:string,handler:Handler):error
	export const LocalAddrContextKey:Ref<>
	export interface MaxBytesError extends Struct<MaxBytesError>,Error,GoError{
		limit:int64
		error():string
	}
	export function maxBytesHandler(h:Handler,n:int64):Handler
	export function maxBytesReader(w:ResponseWriter,r:io.ReadCloser,n:int64):io.ReadCloser
	//"CONNECT"
	export const MethodConnect:string
	//"DELETE"
	export const MethodDelete:string
	//"GET"
	export const MethodGet:string
	//"HEAD"
	export const MethodHead:string
	//"OPTIONS"
	export const MethodOptions:string
	//"PATCH"
	export const MethodPatch:string
	//"POST"
	export const MethodPost:string
	//"PUT"
	export const MethodPut:string
	//"TRACE"
	export const MethodTrace:string
	export function newFileTransport(fs:FileSystem):RoundTripper
	export function newRequest(method:string,url:string,body:io.Reader):[Ref<Request>,error]
	export function newRequestWithContext(ctx:context.Context,method:string,url:string,body:io.Reader):[Ref<Request>,error]
	export function newResponseController(rw:ResponseWriter):Ref<ResponseController>
	export function newServeMux():Ref<ServeMux>
	export const NoBody:
	export function notFound(w:ResponseWriter,r:Ref<Request>):void
	export function notFoundHandler():Handler
	export function parseHTTPVersion(vers:string):[int,int,bool]
	export function parseTime(text:string):time.Time
	export function post(url:string,contentType:string,body:io.Reader):[Ref<Response>,error]
	export function postForm(url:string,data:url.Values):[Ref<Response>,error]
	export interface ProtocolError extends Struct<ProtocolError>,Error,GoError{
		errorString:string
		error():string
		is(err:error):bool
	}
	export function proxyFromEnvironment(req:Ref<Request>):Ref<url.URL>
	export function proxyURL(fixedURL:Ref<url.URL>):(v1:Ref<Request>)=>Ref<url.URL>
	export interface PushOptions extends Struct<PushOptions>{
		method:string
		header:Header
	}
	export interface Pusher{
		push(target:string,opts:Ref<PushOptions>):error
	}
	export function readRequest(b:Ref<bufio.Reader>):Ref<Request>
	export function readResponse(r:Ref<bufio.Reader>,req:Ref<Request>):[Ref<Response>,error]
	export function redirect(w:ResponseWriter,r:Ref<Request>,url:string,code:int):void
	export function redirectHandler(url:string,code:int):Handler
	export interface Request extends Struct<Request>{
		method:string
		url:Ref<url.URL>
		proto:string
		protoMajor:int
		protoMinor:int
		header:Header
		body:io.ReadCloser
		getBody:()=>[io.ReadCloser,error]
		contentLength:int64
		transferEncoding:string[]
		close:bool
		host:string
		form:url.Values
		postForm:url.Values
		multipartForm:Ref<multipart.Form>
		trailer:Header
		remoteAddr:string
		requestURI:string
		tls:Ref<tls.ConnectionState>
		cancel:go.ChanRecv<Nothing>
		response:Ref<Response>
		context():context.Context
		withContext(ctx:context.Context):Ref<Request>
		clone(ctx:context.Context):Ref<Request>
		protoAtLeast(major:int,minor:int):bool
		userAgent():string
		cookies():Ref<Cookie>[]
		cookie(name:string):[Ref<Cookie>,error]
		addCookie(c:Ref<Cookie>):void
		referer():string
		multipartReader():[Ref<multipart.Reader>,error]
		write(w:io.Writer):error
		writeProxy(w:io.Writer):error
		basicAuth():[string,string,bool]
		setBasicAuth(username:string,password:string):void
		parseForm():error
		parseMultipartForm(maxMemory:int64):error
		formValue(key:string):string
		postFormValue(key:string):string
		formFile(key:string):[multipart.File,Ref<multipart.FileHeader>,error]
	}
	export interface Response extends Struct<Response>{
		status:string
		statusCode:int
		proto:string
		protoMajor:int
		protoMinor:int
		header:Header
		body:io.ReadCloser
		contentLength:int64
		transferEncoding:string[]
		close:bool
		uncompressed:bool
		trailer:Header
		request:Ref<Request>
		tls:Ref<tls.ConnectionState>
		cookies():Ref<Cookie>[]
		location():[Ref<url.URL>,error]
		protoAtLeast(major:int,minor:int):bool
		write(w:io.Writer):error
	}
	export interface ResponseController extends Struct<ResponseController>,Hijacker{
		flush():error
		hijack():[net.Conn,Ref<bufio.ReadWriter>,error]
		setReadDeadline(deadline:time.Time):error
		setWriteDeadline(deadline:time.Time):error
		enableFullDuplex():error
	}
	export interface ResponseWriter{
		header():Header
		write(v1:Uint8Array):[int,error]
		writeHeader(statusCode:int):void
	}
	export interface RoundTripper{
		roundTrip(v1:Ref<Request>):[Ref<Response>,error]
	}
	export interface SameSite extends int{
	}
	export const SameSiteDefaultMode:SameSite
	export const SameSiteLaxMode:SameSite
	export const SameSiteNoneMode:SameSite
	export const SameSiteStrictMode:SameSite
	export function serve(l:net.Listener,handler:Handler):error
	export function serveContent(w:ResponseWriter,req:Ref<Request>,name:string,modtime:time.Time,content:io.ReadSeeker):void
	export function serveFile(w:ResponseWriter,r:Ref<Request>,name:string):void
	export interface ServeMux extends Handler,Struct<ServeMux>{
		handler(r:Ref<Request>):[Handler,string]
		serveHTTP(w:ResponseWriter,r:Ref<Request>):void
		handle(pattern:string,handler:Handler):void
		handleFunc(pattern:string,handler:(v2:ResponseWriter,v1:Ref<Request>)=>void):void
	}
	export function serveTLS(l:net.Listener,handler:Handler,certFile:string,keyFile:string):error
	export interface Server extends Struct<Server>,io.Closer{
		addr:string
		handler:Handler
		disableGeneralOptionsHandler:bool
		tlsConfig:Ref<tls.Config>
		readTimeout:time.Duration
		readHeaderTimeout:time.Duration
		writeTimeout:time.Duration
		idleTimeout:time.Duration
		maxHeaderBytes:int
		tlsNextProto:Record<string,(v3:Ref<Server>,v2:Ref<tls.Conn>,v1:Handler)=>void>
		connState:(v2:net.Conn,v1:ConnState)=>void
		errorLog:Ref<log.Logger>
		baseContext:(v1:net.Listener)=>context.Context
		connContext:(ctx:context.Context,c:net.Conn)=>context.Context
		close():error
		shutdown(ctx:context.Context):error
		registerOnShutdown(f:()=>void):void
		listenAndServe():error
		serve(l:net.Listener):error
		serveTLS(l:net.Listener,certFile:string,keyFile:string):error
		setKeepAlivesEnabled(v:bool):void
		listenAndServeTLS(certFile:string,keyFile:string):error
	}
	export const ServerContextKey:Ref<>
	export function setCookie(w:ResponseWriter,cookie:Ref<Cookie>):void
	export const StateActive:ConnState
	export const StateClosed:ConnState
	export const StateHijacked:ConnState
	export const StateIdle:ConnState
	export const StateNew:ConnState
	//202
	export const StatusAccepted:int
	//208
	export const StatusAlreadyReported:int
	//502
	export const StatusBadGateway:int
	//400
	export const StatusBadRequest:int
	//409
	export const StatusConflict:int
	//100
	export const StatusContinue:int
	//201
	export const StatusCreated:int
	//103
	export const StatusEarlyHints:int
	//417
	export const StatusExpectationFailed:int
	//424
	export const StatusFailedDependency:int
	//403
	export const StatusForbidden:int
	//302
	export const StatusFound:int
	//504
	export const StatusGatewayTimeout:int
	//410
	export const StatusGone:int
	//505
	export const StatusHTTPVersionNotSupported:int
	//226
	export const StatusIMUsed:int
	//507
	export const StatusInsufficientStorage:int
	//500
	export const StatusInternalServerError:int
	//411
	export const StatusLengthRequired:int
	//423
	export const StatusLocked:int
	//508
	export const StatusLoopDetected:int
	//405
	export const StatusMethodNotAllowed:int
	//421
	export const StatusMisdirectedRequest:int
	//301
	export const StatusMovedPermanently:int
	//207
	export const StatusMultiStatus:int
	//300
	export const StatusMultipleChoices:int
	//511
	export const StatusNetworkAuthenticationRequired:int
	//204
	export const StatusNoContent:int
	//203
	export const StatusNonAuthoritativeInfo:int
	//406
	export const StatusNotAcceptable:int
	//510
	export const StatusNotExtended:int
	//404
	export const StatusNotFound:int
	//501
	export const StatusNotImplemented:int
	//304
	export const StatusNotModified:int
	//200
	export const StatusOK:int
	//206
	export const StatusPartialContent:int
	//402
	export const StatusPaymentRequired:int
	//308
	export const StatusPermanentRedirect:int
	//412
	export const StatusPreconditionFailed:int
	//428
	export const StatusPreconditionRequired:int
	//102
	export const StatusProcessing:int
	//407
	export const StatusProxyAuthRequired:int
	//413
	export const StatusRequestEntityTooLarge:int
	//431
	export const StatusRequestHeaderFieldsTooLarge:int
	//408
	export const StatusRequestTimeout:int
	//414
	export const StatusRequestURITooLong:int
	//416
	export const StatusRequestedRangeNotSatisfiable:int
	//205
	export const StatusResetContent:int
	//303
	export const StatusSeeOther:int
	//503
	export const StatusServiceUnavailable:int
	//101
	export const StatusSwitchingProtocols:int
	//418
	export const StatusTeapot:int
	//307
	export const StatusTemporaryRedirect:int
	export function statusText(code:int):string
	//425
	export const StatusTooEarly:int
	//429
	export const StatusTooManyRequests:int
	//401
	export const StatusUnauthorized:int
	//451
	export const StatusUnavailableForLegalReasons:int
	//422
	export const StatusUnprocessableEntity:int
	//415
	export const StatusUnsupportedMediaType:int
	//426
	export const StatusUpgradeRequired:int
	//305
	export const StatusUseProxy:int
	//506
	export const StatusVariantAlsoNegotiates:int
	export function stripPrefix(prefix:string,h:Handler):Handler
	//"Mon, 02 Jan 2006 15:04:05 GMT"
	export const TimeFormat:string
	export function timeoutHandler(h:Handler,dt:time.Duration,msg:string):Handler
	//"Trailer:"
	export const TrailerPrefix:string
	export interface Transport extends Struct<Transport>,RoundTripper{
		proxy:(v1:Ref<Request>)=>[Ref<url.URL>,error]
		onProxyConnectResponse:(ctx:context.Context,proxyURL:Ref<url.URL>,connectReq:Ref<Request>,connectRes:Ref<Response>)=>error
		dialContext:(ctx:context.Context,network:string,addr:string)=>[net.Conn,error]
		dial:(network:string,addr:string)=>[net.Conn,error]
		dialTLSContext:(ctx:context.Context,network:string,addr:string)=>[net.Conn,error]
		dialTLS:(network:string,addr:string)=>[net.Conn,error]
		tlsClientConfig:Ref<tls.Config>
		tlsHandshakeTimeout:time.Duration
		disableKeepAlives:bool
		disableCompression:bool
		maxIdleConns:int
		maxIdleConnsPerHost:int
		maxConnsPerHost:int
		idleConnTimeout:time.Duration
		responseHeaderTimeout:time.Duration
		expectContinueTimeout:time.Duration
		tlsNextProto:Record<string,(authority:string,c:Ref<tls.Conn>)=>RoundTripper>
		proxyConnectHeader:Header
		getProxyConnectHeader:(ctx:context.Context,proxyURL:Ref<url.URL>,target:string)=>[Header,error]
		maxResponseHeaderBytes:int64
		writeBufferSize:int
		readBufferSize:int
		forceAttemptHTTP2:bool
		roundTrip(req:Ref<Request>):[Ref<Response>,error]
		clone():Ref<Transport>
		registerProtocol(scheme:string,rt:RoundTripper):void
		closeIdleConnections():void
		cancelRequest(req:Ref<Request>):void
	}

export function emptyClient():Client
export function refClient():Ref<Client>
export function refOfClient(x:Client):Ref<Client>
export function emptyCookie():Cookie
export function refCookie():Ref<Cookie>
export function refOfCookie(x:Cookie):Ref<Cookie>
export function emptyPushOptions():PushOptions
export function refPushOptions():Ref<PushOptions>
export function refOfPushOptions(x:PushOptions):Ref<PushOptions>
export function emptyResponseController():ResponseController
export function refResponseController():Ref<ResponseController>
export function refOfResponseController(x:ResponseController):Ref<ResponseController>
export function emptyRequest():Request
export function refRequest():Ref<Request>
export function refOfRequest(x:Request):Ref<Request>
export function emptyResponse():Response
export function refResponse():Ref<Response>
export function refOfResponse(x:Response):Ref<Response>
export function emptyServeMux():ServeMux
export function refServeMux():Ref<ServeMux>
export function refOfServeMux(x:ServeMux):Ref<ServeMux>
export function emptyServer():Server
export function refServer():Ref<Server>
export function refOfServer(x:Server):Ref<Server>
export function emptyTransport():Transport
export function refTransport():Ref<Transport>
export function refOfTransport(x:Transport):Ref<Transport>}
