// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/net'{
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as go from 'go'
	// @ts-ignore
	import * as syscall from 'golang/syscall'
	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import * as os from 'golang/os'
	// @ts-ignore
	import * as netip from 'golang/net/netip'
	// @ts-ignore
	import type {byte,uint16,bool,int64,error,Ref,uint,Struct,GoError,int,Nothing} from 'go'
	export interface Addr{
		network():string
		string():string
	}
	export interface AddrError extends Struct<AddrError>,Error,GoError{
		err:string
		addr:string
		error():string
		timeout():bool
		temporary():bool
	}
	export interface Buffers extends Array<Uint8Array>{
		writeTo(w:io.Writer):[int64,error]
		read(p:Uint8Array):[int,error]
	}
	export function cidrMask(ones:int,bits:int):IPMask
	export interface Conn extends io.Closer{
		close():error
		localAddr():Addr
		read(b:Uint8Array):[int,error]
		remoteAddr():Addr
		setDeadline(t:time.Time):error
		setReadDeadline(t:time.Time):error
		setWriteDeadline(t:time.Time):error
		write(b:Uint8Array):[int,error]
	}
	export interface DNSConfigError extends Struct<DNSConfigError>,Error,GoError{
		err:GoError
		unwrap():error
		error():string
		timeout():bool
		temporary():bool
	}
	export interface DNSError extends Struct<DNSError>,Error,GoError{
		err:string
		name:string
		server:string
		isTimeout:bool
		isTemporary:bool
		isNotFound:bool
		error():string
		timeout():bool
		temporary():bool
	}
	export const DefaultResolver:Ref<Resolver>
	export function dial(network:string,address:string):[Conn,error]
	export function dialIP(network:string,laddr:Ref<IPAddr>,raddr:Ref<IPAddr>):[Ref<IPConn>,error]
	export function dialTCP(network:string,laddr:Ref<TCPAddr>,raddr:Ref<TCPAddr>):[Ref<TCPConn>,error]
	export function dialTimeout(network:string,address:string,timeout:time.Duration):[Conn,error]
	export function dialUDP(network:string,laddr:Ref<UDPAddr>,raddr:Ref<UDPAddr>):[Ref<UDPConn>,error]
	export function dialUnix(network:string,laddr:Ref<UnixAddr>,raddr:Ref<UnixAddr>):[Ref<UnixConn>,error]
	export interface Dialer extends Struct<Dialer>{
		timeout:time.Duration
		deadline:time.Time
		localAddr:Addr
		dualStack:bool
		fallbackDelay:time.Duration
		keepAlive:time.Duration
		resolver:Ref<Resolver>
		cancel:go.ChanRecv<Nothing>
		control:(network:string,address:string,c:syscall.RawConn)=>error
		controlContext:(ctx:context.Context,network:string,address:string,c:syscall.RawConn)=>error
		multipathTCP():bool
		setMultipathTCP(use:bool):void
		dial(network:string,address:string):[Conn,error]
		dialContext(ctx:context.Context,network:string,address:string):[Conn,error]
	}
	export const ErrClosed:GoError
	export const ErrWriteToConnected:GoError
	export interface Error{
		temporary():bool
		timeout():bool
	}
	export function fileConn(f:Ref<os.File>):Conn
	export function fileListener(f:Ref<os.File>):Listener
	export function filePacketConn(f:Ref<os.File>):PacketConn
	export const FlagBroadcast:Flags
	export const FlagLoopback:Flags
	export const FlagMulticast:Flags
	export const FlagPointToPoint:Flags
	export const FlagRunning:Flags
	export const FlagUp:Flags
	export interface Flags extends uint{
		string():string
	}
	export interface HardwareAddr extends Uint8Array{
		string():string
	}
	export interface IP extends Uint8Array{
		isUnspecified():bool
		isLoopback():bool
		isPrivate():bool
		isMulticast():bool
		isInterfaceLocalMulticast():bool
		isLinkLocalMulticast():bool
		isLinkLocalUnicast():bool
		isGlobalUnicast():bool
		to4():IP
		to16():IP
		defaultMask():IPMask
		mask(mask:IPMask):IP
		string():string
		marshalText():[Uint8Array,error]
		unmarshalText(text:Uint8Array):error
		equal(x:IP):bool
	}
	export interface IPAddr extends Struct<IPAddr>,Addr{
		ip:IP
		zone:string
		network():string
		string():string
	}
	export interface IPConn extends io.ReadCloser,io.ReadWriteCloser,PacketConn,io.ReadWriter,syscall.Conn,io.WriteCloser,Conn,Struct<IPConn>{
		syscallConn():[syscall.RawConn,error]
		readFromIP(b:Uint8Array):[int,Ref<IPAddr>,error]
		readFrom(b:Uint8Array):[int,Addr,error]
		readMsgIP(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<IPAddr>,error]
		writeToIP(b:Uint8Array,addr:Ref<IPAddr>):[int,error]
		writeTo(b:Uint8Array,addr:Addr):[int,error]
		writeMsgIP(b:Uint8Array,oob:Uint8Array,addr:Ref<IPAddr>):[int,int,error]
	}
	export interface IPMask extends Uint8Array{
		size():[int,int]
		string():string
	}
	export interface IPNet extends Addr,Struct<IPNet>{
		ip:IP
		mask:IPMask
		contains(ip:IP):bool
		network():string
		string():string
	}
	export function iPv4(a:byte,b:byte,c:byte,d:byte):IP
	export function iPv4Mask(a:byte,b:byte,c:byte,d:byte):IPMask
	export const IPv4allrouter:IP
	export const IPv4allsys:IP
	export const IPv4bcast:IP
	//4
	export const IPv4len:int
	export const IPv4zero:IP
	export const IPv6interfacelocalallnodes:IP
	//16
	export const IPv6len:int
	export const IPv6linklocalallnodes:IP
	export const IPv6linklocalallrouters:IP
	export const IPv6loopback:IP
	export const IPv6unspecified:IP
	export const IPv6zero:IP
	export interface Interface extends Struct<Interface>{
		index:int
		mtu:int
		name:string
		hardwareAddr:HardwareAddr
		flags:Flags
		addrs():[Addr[],error]
		multicastAddrs():[Addr[],error]
	}
	export function interfaceAddrs():[Addr]
	export function interfaceByIndex(index:int):Ref<Interface>
	export function interfaceByName(name:string):Ref<Interface>
	export function interfaces():[Interface]
	export interface InvalidAddrError extends string,GoError{
		error():string
		timeout():bool
		temporary():bool
	}
	export function joinHostPort(host:string,port:string):string
	export function listen(network:string,address:string):[Listener,error]
	export interface ListenConfig extends Struct<ListenConfig>{
		control:(network:string,address:string,c:syscall.RawConn)=>error
		keepAlive:time.Duration
		multipathTCP():bool
		setMultipathTCP(use:bool):void
		listen(ctx:context.Context,network:string,address:string):[Listener,error]
		listenPacket(ctx:context.Context,network:string,address:string):[PacketConn,error]
	}
	export function listenIP(network:string,laddr:Ref<IPAddr>):[Ref<IPConn>,error]
	export function listenMulticastUDP(network:string,ifi:Ref<Interface>,gaddr:Ref<UDPAddr>):[Ref<UDPConn>,error]
	export function listenPacket(network:string,address:string):[PacketConn,error]
	export function listenTCP(network:string,laddr:Ref<TCPAddr>):[Ref<TCPListener>,error]
	export function listenUDP(network:string,laddr:Ref<UDPAddr>):[Ref<UDPConn>,error]
	export function listenUnix(network:string,laddr:Ref<UnixAddr>):[Ref<UnixListener>,error]
	export function listenUnixgram(network:string,laddr:Ref<UnixAddr>):[Ref<UnixConn>,error]
	export interface Listener extends io.Closer{
		accept():[Conn,error]
		addr():Addr
		close():error
	}
	export function lookupAddr(addr:string):[string]
	export function lookupCNAME(host:string):string
	export function lookupHost(host:string):[string]
	export function lookupIP(host:string):[IP]
	export function lookupMX(name:string):[Ref<MX>]
	export function lookupNS(name:string):[Ref<NS>]
	export function lookupPort(network:string,service:string):[int,error]
	export function lookupSRV(service:string,proto:string,name:string):[string,Ref<SRV>[],error]
	export function lookupTXT(name:string):[string]
	export interface MX extends Struct<MX>{
		host:string
		pref:uint16
	}
	export interface NS extends Struct<NS>{
		host:string
	}
	export interface OpError extends Struct<OpError>,Error,GoError{
		op:string
		net:string
		source:Addr
		addr:Addr
		err:GoError
		unwrap():error
		error():string
		timeout():bool
		temporary():bool
	}
	export interface PacketConn extends io.Closer{
		close():error
		localAddr():Addr
		readFrom(p:Uint8Array):[int,Addr,error]
		setDeadline(t:time.Time):error
		setReadDeadline(t:time.Time):error
		setWriteDeadline(t:time.Time):error
		writeTo(p:Uint8Array,addr:Addr):[int,error]
	}
	export function parseCIDR(s:string):[IP,Ref<IPNet>,error]
	export interface ParseError extends Struct<ParseError>,Error,GoError{
		type:string
		text:string
		error():string
		timeout():bool
		temporary():bool
	}
	export function parseIP(s:string):IP
	export function parseMAC(s:string):HardwareAddr
	export function pipe():[Conn,Conn]
	export function resolveIPAddr(network:string,address:string):[Ref<IPAddr>,error]
	export function resolveTCPAddr(network:string,address:string):[Ref<TCPAddr>,error]
	export function resolveUDPAddr(network:string,address:string):[Ref<UDPAddr>,error]
	export function resolveUnixAddr(network:string,address:string):[Ref<UnixAddr>,error]
	export interface Resolver extends Struct<Resolver>{
		preferGo:bool
		strictErrors:bool
		dial:(ctx:context.Context,network:string,address:string)=>[Conn,error]
		lookupHost(ctx:context.Context,host:string):[string[],error]
		lookupIPAddr(ctx:context.Context,host:string):[IPAddr[],error]
		lookupIP(ctx:context.Context,network:string,host:string):[IP[],error]
		lookupNetIP(ctx:context.Context,network:string,host:string):[netip.Addr[],error]
		lookupPort(ctx:context.Context,network:string,service:string):[int,error]
		lookupCNAME(ctx:context.Context,host:string):[string,error]
		lookupSRV(ctx:context.Context,service:string,proto:string,name:string):[string,Ref<SRV>[],error]
		lookupMX(ctx:context.Context,name:string):[Ref<MX>[],error]
		lookupNS(ctx:context.Context,name:string):[Ref<NS>[],error]
		lookupTXT(ctx:context.Context,name:string):[string[],error]
		lookupAddr(ctx:context.Context,addr:string):[string[],error]
	}
	export interface SRV extends Struct<SRV>{
		target:string
		port:uint16
		priority:uint16
		weight:uint16
	}
	export function splitHostPort(hostport:string):[string,string,error]
	export interface TCPAddr extends Struct<TCPAddr>,Addr{
		ip:IP
		port:int
		zone:string
		addrPort():netip.AddrPort
		network():string
		string():string
	}
	export function tcpAddrFromAddrPort(addr:netip.AddrPort):Ref<TCPAddr>
	export interface TCPConn extends io.ReaderFrom,io.ReadCloser,io.ReadWriteCloser,Struct<TCPConn>,io.ReadWriter,syscall.Conn,io.WriteCloser,Conn{
		syscallConn():[syscall.RawConn,error]
		readFrom(r:io.Reader):[int64,error]
		closeRead():error
		closeWrite():error
		setLinger(sec:int):error
		setKeepAlive(keepalive:bool):error
		setKeepAlivePeriod(d:time.Duration):error
		setNoDelay(noDelay:bool):error
		multipathTCP():[bool,error]
	}
	export interface TCPListener extends Struct<TCPListener>,io.Closer,Listener,syscall.Conn{
		syscallConn():[syscall.RawConn,error]
		acceptTCP():[Ref<TCPConn>,error]
		accept():[Conn,error]
		close():error
		addr():Addr
		setDeadline(t:time.Time):error
		file():[Ref<os.File>,error]
	}
	export interface UDPAddr extends Struct<UDPAddr>,Addr{
		ip:IP
		port:int
		zone:string
		addrPort():netip.AddrPort
		network():string
		string():string
	}
	export function udpAddrFromAddrPort(addr:netip.AddrPort):Ref<UDPAddr>
	export interface UDPConn extends io.ReadCloser,io.ReadWriteCloser,PacketConn,io.ReadWriter,Struct<UDPConn>,syscall.Conn,io.WriteCloser,Conn{
		syscallConn():[syscall.RawConn,error]
		readFromUDP(b:Uint8Array):[int,Ref<UDPAddr>,error]
		readFrom(b:Uint8Array):[int,Addr,error]
		readFromUDPAddrPort(b:Uint8Array):[int,netip.AddrPort,error]
		readMsgUDP(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<UDPAddr>,error]
		readMsgUDPAddrPort(b:Uint8Array,oob:Uint8Array):[int,int,int,netip.AddrPort,error]
		writeToUDP(b:Uint8Array,addr:Ref<UDPAddr>):[int,error]
		writeToUDPAddrPort(b:Uint8Array,addr:netip.AddrPort):[int,error]
		writeTo(b:Uint8Array,addr:Addr):[int,error]
		writeMsgUDP(b:Uint8Array,oob:Uint8Array,addr:Ref<UDPAddr>):[int,int,error]
		writeMsgUDPAddrPort(b:Uint8Array,oob:Uint8Array,addr:netip.AddrPort):[int,int,error]
	}
	export interface UnixAddr extends Struct<UnixAddr>,Addr{
		name:string
		net:string
		network():string
		string():string
	}
	export interface UnixConn extends PacketConn,io.ReadCloser,io.ReadWriteCloser,io.ReadWriter,Struct<UnixConn>,syscall.Conn,io.WriteCloser,Conn{
		syscallConn():[syscall.RawConn,error]
		closeRead():error
		closeWrite():error
		readFromUnix(b:Uint8Array):[int,Ref<UnixAddr>,error]
		readFrom(b:Uint8Array):[int,Addr,error]
		readMsgUnix(b:Uint8Array,oob:Uint8Array):[int,int,int,Ref<UnixAddr>,error]
		writeToUnix(b:Uint8Array,addr:Ref<UnixAddr>):[int,error]
		writeTo(b:Uint8Array,addr:Addr):[int,error]
		writeMsgUnix(b:Uint8Array,oob:Uint8Array,addr:Ref<UnixAddr>):[int,int,error]
	}
	export interface UnixListener extends Struct<UnixListener>,Listener,syscall.Conn,io.Closer{
		syscallConn():[syscall.RawConn,error]
		acceptUnix():[Ref<UnixConn>,error]
		accept():[Conn,error]
		close():error
		addr():Addr
		setDeadline(t:time.Time):error
		file():[Ref<os.File>,error]
		setUnlinkOnClose(unlink:bool):void
	}
	export interface UnknownNetworkError extends string,GoError{
		error():string
		timeout():bool
		temporary():bool
	}

export function emptyIPNet():IPNet
export function refIPNet():Ref<IPNet>
export function refOfIPNet(x:IPNet):Ref<IPNet>
export function emptyTCPListener():TCPListener
export function refTCPListener():Ref<TCPListener>
export function refOfTCPListener(x:TCPListener):Ref<TCPListener>
export function emptyUnixConn():UnixConn
export function refUnixConn():Ref<UnixConn>
export function refOfUnixConn(x:UnixConn):Ref<UnixConn>
export function emptyUnixListener():UnixListener
export function refUnixListener():Ref<UnixListener>
export function refOfUnixListener(x:UnixListener):Ref<UnixListener>
export function emptyIPConn():IPConn
export function refIPConn():Ref<IPConn>
export function refOfIPConn(x:IPConn):Ref<IPConn>
export function emptyIPAddr():IPAddr
export function refIPAddr():Ref<IPAddr>
export function refOfIPAddr(x:IPAddr):Ref<IPAddr>
export function emptyUDPConn():UDPConn
export function refUDPConn():Ref<UDPConn>
export function refOfUDPConn(x:UDPConn):Ref<UDPConn>
export function emptyTCPConn():TCPConn
export function refTCPConn():Ref<TCPConn>
export function refOfTCPConn(x:TCPConn):Ref<TCPConn>
export function emptyUnixAddr():UnixAddr
export function refUnixAddr():Ref<UnixAddr>
export function refOfUnixAddr(x:UnixAddr):Ref<UnixAddr>
export function emptyListenConfig():ListenConfig
export function refListenConfig():Ref<ListenConfig>
export function refOfListenConfig(x:ListenConfig):Ref<ListenConfig>
export function emptyMX():MX
export function refMX():Ref<MX>
export function refOfMX(x:MX):Ref<MX>
export function emptyResolver():Resolver
export function refResolver():Ref<Resolver>
export function refOfResolver(x:Resolver):Ref<Resolver>
export function emptyTCPAddr():TCPAddr
export function refTCPAddr():Ref<TCPAddr>
export function refOfTCPAddr(x:TCPAddr):Ref<TCPAddr>
export function emptySRV():SRV
export function refSRV():Ref<SRV>
export function refOfSRV(x:SRV):Ref<SRV>
export function emptyUDPAddr():UDPAddr
export function refUDPAddr():Ref<UDPAddr>
export function refOfUDPAddr(x:UDPAddr):Ref<UDPAddr>
export function emptyDialer():Dialer
export function refDialer():Ref<Dialer>
export function refOfDialer(x:Dialer):Ref<Dialer>
export function emptyInterface():Interface
export function refInterface():Ref<Interface>
export function refOfInterface(x:Interface):Ref<Interface>
export function emptyNS():NS
export function refNS():Ref<NS>
export function refOfNS(x:NS):Ref<NS>}
