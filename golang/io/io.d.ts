// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/io'{
	// @ts-ignore
	import type {Struct,int,Ref,rune,byte,error,int64,GoError} from 'go'
	export interface ByteReader{
		readByte():byte
	}
	export interface ByteScanner extends ByteReader{
		unreadByte()/*error*/
	}
	export interface ByteWriter{
		writeByte(c:byte)/*error*/
	}
	export interface Closer{
		close():error
	}
	export function copy(dst:Writer,src:Reader):int64
	export function copyBuffer(dst:Writer,src:Reader,buf:Uint8Array):int64
	export function copyN(dst:Writer,src:Reader,n:int64):int64
	export const Discard:Writer
	export const EOF:GoError
	export const ErrClosedPipe:GoError
	export const ErrNoProgress:GoError
	export const ErrShortBuffer:GoError
	export const ErrShortWrite:GoError
	export const ErrUnexpectedEOF:GoError
	export function limitReader(r:Reader,n:int64):Reader
	export interface LimitedReader extends Struct<LimitedReader>,Reader{
		R:Reader
		N:int64
		read(p:Uint8Array):int
	}
	export function multiReader(...readers:Reader[]):Reader
	export function multiWriter(...writers:Writer[]):Writer
	export function newOffsetWriter(w:WriterAt,off:int64):Ref<OffsetWriter>
	export function newSectionReader(r:ReaderAt,off:int64,n:int64):Ref<SectionReader>
	export function nopCloser(r:Reader):ReadCloser
	export interface OffsetWriter extends Struct<OffsetWriter>,WriteSeeker,WriterAt{
		write(p:Uint8Array):int
		writeAt(p:Uint8Array,off:int64):int
		seek(offset:int64,whence:int):int64
	}
	export function pipe():[Ref<PipeReader>,Ref<PipeWriter>]
	export interface PipeReader extends ReadCloser,Closer,Struct<PipeReader>{
		read(data:Uint8Array):int
		close():error
		closeWithError(err:error)/*error*/
	}
	export interface PipeWriter extends Struct<PipeWriter>,WriteCloser,Closer{
		write(data:Uint8Array):int
		close():error
		closeWithError(err:error)/*error*/
	}
	export function readAll(r:Reader):Uint8Array
	export function readAtLeast(r:Reader,buf:Uint8Array,min:int):int
	export interface ReadCloser extends Reader,Closer{
	}
	export function readFull(r:Reader,buf:Uint8Array):int
	export interface ReadSeekCloser extends Reader,Seeker,Closer{
	}
	export interface ReadSeeker extends Reader,Seeker{
	}
	export interface ReadWriteCloser extends Reader,Writer,Closer{
	}
	export interface ReadWriteSeeker extends Reader,Writer,Seeker{
	}
	export interface ReadWriter extends Reader,Writer{
	}
	export interface Reader{
		read(p:Uint8Array):int
	}
	export interface ReaderAt{
		readAt(p:Uint8Array,off:int64):int
	}
	export interface ReaderFrom{
		readFrom(r:Reader):int64
	}
	export interface RuneReader{
		readRune():[rune,int]
	}
	export interface RuneScanner extends RuneReader{
		unreadRune()/*error*/
	}
	export interface SectionReader extends Struct<SectionReader>,ReadSeeker,ReaderAt{
		read(p:Uint8Array):int
		seek(offset:int64,whence:int):int64
		readAt(p:Uint8Array,off:int64):int
		size():int64
	}
	//1
	export const SeekCurrent:int
	//2
	export const SeekEnd:int
	//0
	export const SeekStart:int
	export interface Seeker{
		seek(offset:int64,whence:int):int64
	}
	export interface StringWriter{
		writeString(s:string):int
	}
	export function teeReader(r:Reader,w:Writer):Reader
	export interface WriteCloser extends Writer,Closer{
	}
	export interface WriteSeeker extends Writer,Seeker{
	}
	export function writeString(w:Writer,s:string):int
	export interface Writer{
		write(p:Uint8Array):int
	}
	export interface WriterAt{
		writeAt(p:Uint8Array,off:int64):int
	}
	export interface WriterTo{
		writeTo(w:Writer):int64
	}

export function emptyLimitedReader():LimitedReader
export function refLimitedReader():Ref<LimitedReader>
export function refOfLimitedReader(x:LimitedReader):Ref<LimitedReader>
export function emptyOffsetWriter():OffsetWriter
export function refOffsetWriter():Ref<OffsetWriter>
export function refOfOffsetWriter(x:OffsetWriter):Ref<OffsetWriter>
export function emptyPipeReader():PipeReader
export function refPipeReader():Ref<PipeReader>
export function refOfPipeReader(x:PipeReader):Ref<PipeReader>
export function emptyPipeWriter():PipeWriter
export function refPipeWriter():Ref<PipeWriter>
export function refOfPipeWriter(x:PipeWriter):Ref<PipeWriter>
export function emptySectionReader():SectionReader
export function refSectionReader():Ref<SectionReader>
export function refOfSectionReader(x:SectionReader):Ref<SectionReader>
}
