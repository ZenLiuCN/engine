// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/crypto/tls'{
	// @ts-ignore
	import * as crypto from 'golang/crypto'
	// @ts-ignore
	import * as x509 from 'golang/crypto/x509'
	// @ts-ignore
	import * as context from 'golang/context'
	// @ts-ignore
	import * as net from 'golang/net'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import type {Struct,uint16,error,bool,int,uint8,GoError,Ref} from 'go'
	export interface AlertError extends uint8,GoError{
		error():string
	}
	export interface Certificate extends Struct<Certificate>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey{
		certificate:Array<Uint8Array>
		privateKey:crypto.PrivateKey
		supportedSignatureAlgorithms:SignatureScheme[]
		ocspStaple:Uint8Array
		signedCertificateTimestamps:Array<Uint8Array>
		leaf:Ref<x509.Certificate>
	}
	export interface CertificateRequestInfo extends Struct<CertificateRequestInfo>,crypto.PublicKey,crypto.PrivateKey,crypto.DecrypterOpts{
		acceptableCAs:Array<Uint8Array>
		signatureSchemes:SignatureScheme[]
		version:uint16
		context():context.Context
		supportsCertificate(c:Ref<Certificate>)/*error*/
	}
	export interface CertificateVerificationError extends Struct<CertificateVerificationError>,Error,GoError{
		unverifiedCertificates:Ref<x509.Certificate>[]
		err:GoError
		error():string
		unwrap()/*error*/
	}
	export interface CipherSuite extends crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey,Struct<CipherSuite>{
		id:uint16
		name:string
		supportedVersions:Uint16Array
		insecure:bool
	}
	export function cipherSuiteName(id:uint16):string
	export function cipherSuites():Ref<CipherSuite>[]
	export function client(conn:net.Conn,config:Ref<Config>):Ref<Conn>
	export interface ClientAuthType extends int{
		string():string
	}
	export interface ClientHelloInfo extends Struct<ClientHelloInfo>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{
		cipherSuites:Uint16Array
		serverName:string
		supportedCurves:CurveID[]
		supportedPoints:Uint8Array
		signatureSchemes:SignatureScheme[]
		supportedProtos:string[]
		supportedVersions:Uint16Array
		conn:net.Conn
		context():context.Context
		supportsCertificate(c:Ref<Certificate>)/*error*/
	}
	export interface ClientSessionCache{
		get(sessionKey:string):[Ref<ClientSessionState>,bool]
		put(sessionKey:string,cs:Ref<ClientSessionState>):void
	}
	export interface ClientSessionState extends crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey,Struct<ClientSessionState>{
		resumptionState():[Uint8Array,Ref<SessionState>]
	}
	export interface Config extends Struct<Config>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{
		rand:io.Reader
		time:()=>time.Time
		certificates:Certificate[]
		nameToCertificate:Record<string,Ref<Certificate>>
		getCertificate:(v1:Ref<ClientHelloInfo>)=>Ref<Certificate>
		getClientCertificate:(v1:Ref<CertificateRequestInfo>)=>Ref<Certificate>
		getConfigForClient:(v1:Ref<ClientHelloInfo>)=>Ref<Config>
		verifyPeerCertificate:(rawCerts:Array<Uint8Array>,verifiedChains:Ref<x509.Certificate>[][]))=>void/*error*/
		verifyConnection:(v1:ConnectionState))=>void/*error*/
		rootCAs:Ref<x509.CertPool>
		nextProtos:string[]
		serverName:string
		clientAuth:ClientAuthType
		clientCAs:Ref<x509.CertPool>
		insecureSkipVerify:bool
		cipherSuites:Uint16Array
		preferServerCipherSuites:bool
		sessionTicketsDisabled:bool
		sessionTicketKey:Uint8Array/*32*/
		clientSessionCache:ClientSessionCache
		unwrapSession:(identity:Uint8Array,cs:ConnectionState)=>Ref<SessionState>
		wrapSession:(v2:ConnectionState,v1:Ref<SessionState>)=>Uint8Array
		minVersion:uint16
		maxVersion:uint16
		curvePreferences:CurveID[]
		dynamicRecordSizingDisabled:bool
		renegotiation:RenegotiationSupport
		keyLogWriter:io.Writer
		clone():Ref<Config>
		setSessionTicketKeys(keys:Array<Uint8Array>):void
		buildNameToCertificate():void
		encryptTicket(cs:ConnectionState,ss:Ref<SessionState>):Uint8Array
		decryptTicket(identity:Uint8Array,cs:ConnectionState):Ref<SessionState>
	}
	export interface Conn extends crypto.PrivateKey,io.ReadWriteCloser,net.Conn,Struct<Conn>,io.WriteCloser,io.ReadCloser,crypto.PublicKey,io.Closer,io.ReadWriter,crypto.DecrypterOpts{
		localAddr():net.Addr
		remoteAddr():net.Addr
		setDeadline(t:time.Time)/*error*/
		setReadDeadline(t:time.Time)/*error*/
		setWriteDeadline(t:time.Time)/*error*/
		netConn():net.Conn
		write(b:Uint8Array):int
		read(b:Uint8Array):int
		close():error
		closeWrite()/*error*/
		handshake()/*error*/
		handshakeContext(ctx:context.Context)/*error*/
		connectionState():ConnectionState
		ocspResponse():Uint8Array
		verifyHostname(host:string)/*error*/
	}
	export interface ConnectionState extends Struct<ConnectionState>,crypto.PublicKey,crypto.PrivateKey,crypto.DecrypterOpts{
		version:uint16
		handshakeComplete:bool
		didResume:bool
		cipherSuite:uint16
		negotiatedProtocol:string
		negotiatedProtocolIsMutual:bool
		serverName:string
		peerCertificates:Ref<x509.Certificate>[]
		verifiedChains:Ref<x509.Certificate>[][]
		signedCertificateTimestamps:Array<Uint8Array>
		ocspResponse:Uint8Array
		tlsUnique:Uint8Array
		exportKeyingMaterial(label:string,context:Uint8Array,length:int):Uint8Array
	}
	export interface CurveID extends uint16{
		string():string
	}
	export const CurveP256:CurveID
	export const CurveP384:CurveID
	export const CurveP521:CurveID
	export function dial(network:string,addr:string,config:Ref<Config>):Ref<Conn>
	export function dialWithDialer(dialer:Ref<net.Dialer>,network:string,addr:string,config:Ref<Config>):Ref<Conn>
	export interface Dialer extends Struct<Dialer>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey{
		netDialer:Ref<net.Dialer>
		config:Ref<Config>
		dial(network:string,addr:string):net.Conn
		dialContext(ctx:context.Context,network:string,addr:string):net.Conn
	}
	export const ECDSAWithP256AndSHA256:SignatureScheme
	export const ECDSAWithP384AndSHA384:SignatureScheme
	export const ECDSAWithP521AndSHA512:SignatureScheme
	export const ECDSAWithSHA1:SignatureScheme
	export const Ed25519:SignatureScheme
	export function insecureCipherSuites():Ref<CipherSuite>[]
	export function listen(network:string,laddr:string,config:Ref<Config>):net.Listener
	export function loadX509KeyPair(certFile:string,keyFile:string):Certificate
	export function newLRUClientSessionCache(capacity:int):ClientSessionCache
	export function newListener(inner:net.Listener,config:Ref<Config>):net.Listener
	export function newResumptionState(ticket:Uint8Array,state:Ref<SessionState>):Ref<ClientSessionState>
	export const NoClientCert:ClientAuthType
	export const PKCS1WithSHA1:SignatureScheme
	export const PKCS1WithSHA256:SignatureScheme
	export const PKCS1WithSHA384:SignatureScheme
	export const PKCS1WithSHA512:SignatureScheme
	export const PSSWithSHA256:SignatureScheme
	export const PSSWithSHA384:SignatureScheme
	export const PSSWithSHA512:SignatureScheme
	export function parseSessionState(data:Uint8Array):Ref<SessionState>
	export function quicClient(config:Ref<QUICConfig>):Ref<QUICConn>
	export interface QUICConfig extends crypto.DecrypterOpts,Struct<QUICConfig>,crypto.PrivateKey,crypto.PublicKey{
		tlsConfig:Ref<Config>
	}
	export interface QUICConn extends Struct<QUICConn>,crypto.PublicKey,crypto.PrivateKey,io.Closer,crypto.DecrypterOpts{
		start(ctx:context.Context)/*error*/
		nextEvent():QUICEvent
		close():error
		handleData(level:QUICEncryptionLevel,data:Uint8Array)/*error*/
		sendSessionTicket(opts:QUICSessionTicketOptions)/*error*/
		connectionState():ConnectionState
		setTransportParameters(params:Uint8Array):void
	}
	export interface QUICEncryptionLevel extends int{
		string():string
	}
	export const QUICEncryptionLevelApplication:QUICEncryptionLevel
	export const QUICEncryptionLevelEarly:QUICEncryptionLevel
	export const QUICEncryptionLevelHandshake:QUICEncryptionLevel
	export const QUICEncryptionLevelInitial:QUICEncryptionLevel
	export interface QUICEvent extends crypto.DecrypterOpts,crypto.PublicKey,Struct<QUICEvent>,crypto.PrivateKey{
		kind:QUICEventKind
		level:QUICEncryptionLevel
		data:Uint8Array
		suite:uint16
	}
	export interface QUICEventKind extends int{
	}
	export const QUICHandshakeDone:QUICEventKind
	export const QUICNoEvent:QUICEventKind
	export const QUICRejectedEarlyData:QUICEventKind
	export function quicServer(config:Ref<QUICConfig>):Ref<QUICConn>
	export interface QUICSessionTicketOptions extends crypto.PrivateKey,Struct<QUICSessionTicketOptions>,crypto.PublicKey,crypto.DecrypterOpts{
		earlyData:bool
	}
	export const QUICSetReadSecret:QUICEventKind
	export const QUICSetWriteSecret:QUICEventKind
	export const QUICTransportParameters:QUICEventKind
	export const QUICTransportParametersRequired:QUICEventKind
	export const QUICWriteData:QUICEventKind
	export interface RecordHeaderError extends GoError,Struct<RecordHeaderError>,Error{
		msg:string
		recordHeader:Uint8Array/*5*/
		conn:net.Conn
		error():string
	}
	export const RenegotiateFreelyAsClient:RenegotiationSupport
	export const RenegotiateNever:RenegotiationSupport
	export const RenegotiateOnceAsClient:RenegotiationSupport
	export interface RenegotiationSupport extends int{
	}
	export const RequestClientCert:ClientAuthType
	export const RequireAndVerifyClientCert:ClientAuthType
	export const RequireAnyClientCert:ClientAuthType
	export function server(conn:net.Conn,config:Ref<Config>):Ref<Conn>
	export interface SessionState extends Struct<SessionState>,crypto.PublicKey,crypto.DecrypterOpts,crypto.PrivateKey{
		extra:Array<Uint8Array>
		earlyData:bool
		bytes():Uint8Array
	}
	export interface SignatureScheme extends uint16{
		string():string
	}
	//4865
	export const TLS_AES_128_GCM_SHA256:uint16
	//4866
	export const TLS_AES_256_GCM_SHA384:uint16
	//4867
	export const TLS_CHACHA20_POLY1305_SHA256:uint16
	//49161
	export const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:uint16
	//49187
	export const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:uint16
	//49195
	export const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:uint16
	//49162
	export const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:uint16
	//49196
	export const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:uint16
	//52393
	export const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305:uint16
	//52393
	export const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:uint16
	//49159
	export const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:uint16
	//49170
	export const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:uint16
	//49171
	export const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:uint16
	//49191
	export const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:uint16
	//49199
	export const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:uint16
	//49172
	export const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:uint16
	//49200
	export const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:uint16
	//52392
	export const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305:uint16
	//52392
	export const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:uint16
	//49169
	export const TLS_ECDHE_RSA_WITH_RC4_128_SHA:uint16
	//22016
	export const TLS_FALLBACK_SCSV:uint16
	//10
	export const TLS_RSA_WITH_3DES_EDE_CBC_SHA:uint16
	//47
	export const TLS_RSA_WITH_AES_128_CBC_SHA:uint16
	//60
	export const TLS_RSA_WITH_AES_128_CBC_SHA256:uint16
	//156
	export const TLS_RSA_WITH_AES_128_GCM_SHA256:uint16
	//53
	export const TLS_RSA_WITH_AES_256_CBC_SHA:uint16
	//157
	export const TLS_RSA_WITH_AES_256_GCM_SHA384:uint16
	//5
	export const TLS_RSA_WITH_RC4_128_SHA:uint16
	export const VerifyClientCertIfGiven:ClientAuthType
	export function versionName(version:uint16):string
	//768
	export const VersionSSL30:int
	//769
	export const VersionTLS10:int
	//770
	export const VersionTLS11:int
	//771
	export const VersionTLS12:int
	//772
	export const VersionTLS13:int
	export const X25519:CurveID
	export function x509KeyPair(certPEMBlock:Uint8Array,keyPEMBlock:Uint8Array):Certificate

export function emptyCertificate():Certificate
export function refCertificate():Ref<Certificate>
export function refOfCertificate(x:Certificate):Ref<Certificate>
export function emptyCertificateRequestInfo():CertificateRequestInfo
export function refCertificateRequestInfo():Ref<CertificateRequestInfo>
export function refOfCertificateRequestInfo(x:CertificateRequestInfo):Ref<CertificateRequestInfo>
export function emptySessionState():SessionState
export function refSessionState():Ref<SessionState>
export function refOfSessionState(x:SessionState):Ref<SessionState>
export function emptyQUICConfig():QUICConfig
export function refQUICConfig():Ref<QUICConfig>
export function refOfQUICConfig(x:QUICConfig):Ref<QUICConfig>
export function emptyCipherSuite():CipherSuite
export function refCipherSuite():Ref<CipherSuite>
export function refOfCipherSuite(x:CipherSuite):Ref<CipherSuite>
export function emptyClientHelloInfo():ClientHelloInfo
export function refClientHelloInfo():Ref<ClientHelloInfo>
export function refOfClientHelloInfo(x:ClientHelloInfo):Ref<ClientHelloInfo>
export function emptyConfig():Config
export function refConfig():Ref<Config>
export function refOfConfig(x:Config):Ref<Config>
export function emptyConn():Conn
export function refConn():Ref<Conn>
export function refOfConn(x:Conn):Ref<Conn>
export function emptyConnectionState():ConnectionState
export function refConnectionState():Ref<ConnectionState>
export function refOfConnectionState(x:ConnectionState):Ref<ConnectionState>
export function emptyDialer():Dialer
export function refDialer():Ref<Dialer>
export function refOfDialer(x:Dialer):Ref<Dialer>
export function emptyQUICSessionTicketOptions():QUICSessionTicketOptions
export function refQUICSessionTicketOptions():Ref<QUICSessionTicketOptions>
export function refOfQUICSessionTicketOptions(x:QUICSessionTicketOptions):Ref<QUICSessionTicketOptions>
export function emptyClientSessionState():ClientSessionState
export function refClientSessionState():Ref<ClientSessionState>
export function refOfClientSessionState(x:ClientSessionState):Ref<ClientSessionState>
export function emptyQUICConn():QUICConn
export function refQUICConn():Ref<QUICConn>
export function refOfQUICConn(x:QUICConn):Ref<QUICConn>
export function emptyQUICEvent():QUICEvent
export function refQUICEvent():Ref<QUICEvent>
export function refOfQUICEvent(x:QUICEvent):Ref<QUICEvent>
}
