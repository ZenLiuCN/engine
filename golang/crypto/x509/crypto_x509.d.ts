// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/crypto/x509'{
	// @ts-ignore
	import * as asn1 from 'golang/encoding/asn1'
	// @ts-ignore
	import * as url from 'golang/net/url'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as ecdsa from 'golang/crypto/ecdsa'
	// @ts-ignore
	import * as crypto from 'golang/crypto'
	// @ts-ignore
	import * as big from 'golang/math/big'
	// @ts-ignore
	import * as pkix from 'golang/crypto/x509/pkix'
	// @ts-ignore
	import * as rsa from 'golang/crypto/rsa'
	// @ts-ignore
	import * as time from 'golang/time'
	// @ts-ignore
	import * as net from 'golang/net'
	// @ts-ignore
	import * as pem from 'golang/encoding/pem'
	// @ts-ignore
	import type {Nothing,Alias,Struct,Ref,bool,int,error,GoError} from 'go'
	export const CANotAuthorizedForExtKeyUsage:InvalidReason
	export const CANotAuthorizedForThisName:InvalidReason
	export interface CertPool extends crypto.PrivateKey,Struct<CertPool>,crypto.DecrypterOpts,crypto.PublicKey{
		clone():Ref<CertPool>
		addCert(cert:Ref<Certificate>):void
		appendCertsFromPEM(pemCerts:Uint8Array):bool
		subjects():Array<Uint8Array>
		equal(other:Ref<CertPool>):bool
	}
	export interface Certificate extends Struct<Certificate>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{
		raw:Uint8Array
		rawTBSCertificate:Uint8Array
		rawSubjectPublicKeyInfo:Uint8Array
		rawSubject:Uint8Array
		rawIssuer:Uint8Array
		signature:Uint8Array
		signatureAlgorithm:SignatureAlgorithm
		publicKeyAlgorithm:PublicKeyAlgorithm
		publicKey:any
		version:int
		serialNumber:Ref<big.Int>
		issuer:pkix.Name
		subject:pkix.Name
		notBefore:time.Time
		notAfter:time.Time
		keyUsage:KeyUsage
		extensions:pkix.Extension[]
		extraExtensions:pkix.Extension[]
		unhandledCriticalExtensions:asn1.ObjectIdentifier[]
		extKeyUsage:ExtKeyUsage[]
		unknownExtKeyUsage:asn1.ObjectIdentifier[]
		basicConstraintsValid:bool
		isCA:bool
		maxPathLen:int
		maxPathLenZero:bool
		subjectKeyId:Uint8Array
		authorityKeyId:Uint8Array
		ocspServer:string[]
		issuingCertificateURL:string[]
		dnsNames:string[]
		emailAddresses:string[]
		ipAddresses:net.IP[]
		urIs:Ref<url.URL>[]
		permittedDNSDomainsCritical:bool
		permittedDNSDomains:string[]
		excludedDNSDomains:string[]
		permittedIPRanges:Ref<net.IPNet>[]
		excludedIPRanges:Ref<net.IPNet>[]
		permittedEmailAddresses:string[]
		excludedEmailAddresses:string[]
		permittedURIDomains:string[]
		excludedURIDomains:string[]
		crlDistributionPoints:string[]
		policyIdentifiers:asn1.ObjectIdentifier[]
		verify(opts:VerifyOptions):[Ref<Certificate>[][],error]
		verifyHostname(h:string):error
		equal(other:Ref<Certificate>):bool
		checkSignatureFrom(parent:Ref<Certificate>):error
		checkSignature(algo:SignatureAlgorithm,signed:Uint8Array,signature:Uint8Array):error
		checkCRLSignature(crl:Ref<pkix.CertificateList>):error
		createCRL(rand:io.Reader,priv:any,revokedCerts:pkix.RevokedCertificate[],now:time.Time,expiry:time.Time):[Uint8Array,error]
	}
	export interface CertificateInvalidError extends GoError,Struct<CertificateInvalidError>,Error{
		cert:Ref<Certificate>
		reason:InvalidReason
		detail:string
		error():string
	}
	export interface CertificateRequest extends Struct<CertificateRequest>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{
		raw:Uint8Array
		rawTBSCertificateRequest:Uint8Array
		rawSubjectPublicKeyInfo:Uint8Array
		rawSubject:Uint8Array
		version:int
		signature:Uint8Array
		signatureAlgorithm:SignatureAlgorithm
		publicKeyAlgorithm:PublicKeyAlgorithm
		publicKey:any
		subject:pkix.Name
		attributes:pkix.AttributeTypeAndValueSET[]
		extensions:pkix.Extension[]
		extraExtensions:pkix.Extension[]
		dnsNames:string[]
		emailAddresses:string[]
		ipAddresses:net.IP[]
		urIs:Ref<url.URL>[]
		checkSignature():error
	}
	export interface ConstraintViolationError extends Alias<Nothing>,Struct<ConstraintViolationError>,Error,GoError{
		error():string
	}
	export function createCertificate(rand:io.Reader,template:Ref<Certificate>,parent:Ref<Certificate>,pub:any,priv:any):[Uint8Array,error]
	export function createCertificateRequest(rand:io.Reader,template:Ref<CertificateRequest>,priv:any):[Uint8Array,error]
	export function createRevocationList(rand:io.Reader,template:Ref<RevocationList>,issuer:Ref<Certificate>,priv:crypto.Signer):[Uint8Array,error]
	export const DSA:PublicKeyAlgorithm
	export const DSAWithSHA1:SignatureAlgorithm
	export const DSAWithSHA256:SignatureAlgorithm
	export function decryptPEMBlock(b:Ref<pem.Block>,password:Uint8Array):[Uint8Array,error]
	export const ECDSA:PublicKeyAlgorithm
	export const ECDSAWithSHA1:SignatureAlgorithm
	export const ECDSAWithSHA256:SignatureAlgorithm
	export const ECDSAWithSHA384:SignatureAlgorithm
	export const ECDSAWithSHA512:SignatureAlgorithm
	export const Ed25519:PublicKeyAlgorithm
	export function encryptPEMBlock(rand:io.Reader,blockType:string,data:Uint8Array,password:Uint8Array,alg:PEMCipher):[Ref<pem.Block>,error]
	export const ErrUnsupportedAlgorithm:GoError
	export const Expired:InvalidReason
	export interface ExtKeyUsage extends int{
	}
	export const ExtKeyUsageAny:ExtKeyUsage
	export const ExtKeyUsageClientAuth:ExtKeyUsage
	export const ExtKeyUsageCodeSigning:ExtKeyUsage
	export const ExtKeyUsageEmailProtection:ExtKeyUsage
	export const ExtKeyUsageIPSECEndSystem:ExtKeyUsage
	export const ExtKeyUsageIPSECTunnel:ExtKeyUsage
	export const ExtKeyUsageIPSECUser:ExtKeyUsage
	export const ExtKeyUsageMicrosoftCommercialCodeSigning:ExtKeyUsage
	export const ExtKeyUsageMicrosoftKernelCodeSigning:ExtKeyUsage
	export const ExtKeyUsageMicrosoftServerGatedCrypto:ExtKeyUsage
	export const ExtKeyUsageNetscapeServerGatedCrypto:ExtKeyUsage
	export const ExtKeyUsageOCSPSigning:ExtKeyUsage
	export const ExtKeyUsageServerAuth:ExtKeyUsage
	export const ExtKeyUsageTimeStamping:ExtKeyUsage
	export interface HostnameError extends Struct<HostnameError>,Error,GoError{
		certificate:Ref<Certificate>
		host:string
		error():string
	}
	export const IncompatibleUsage:InvalidReason
	export const IncorrectPasswordError:GoError
	export interface InsecureAlgorithmError extends int,GoError{
		error():string
	}
	export interface InvalidReason extends int{
	}
	export function isEncryptedPEMBlock(b:Ref<pem.Block>):bool
	export interface KeyUsage extends int{
	}
	export const KeyUsageCRLSign:KeyUsage
	export const KeyUsageCertSign:KeyUsage
	export const KeyUsageContentCommitment:KeyUsage
	export const KeyUsageDataEncipherment:KeyUsage
	export const KeyUsageDecipherOnly:KeyUsage
	export const KeyUsageDigitalSignature:KeyUsage
	export const KeyUsageEncipherOnly:KeyUsage
	export const KeyUsageKeyAgreement:KeyUsage
	export const KeyUsageKeyEncipherment:KeyUsage
	export const MD2WithRSA:SignatureAlgorithm
	export const MD5WithRSA:SignatureAlgorithm
	export function marshalECPrivateKey(key:Ref<ecdsa.PrivateKey>):Uint8Array
	export function marshalPKCS1PrivateKey(key:Ref<rsa.PrivateKey>):Uint8Array
	export function marshalPKCS1PublicKey(key:Ref<rsa.PublicKey>):Uint8Array
	export function marshalPKCS8PrivateKey(key:any):Uint8Array
	export function marshalPKIXPublicKey(pub:any):Uint8Array
	export const NameConstraintsWithoutSANs:InvalidReason
	export const NameMismatch:InvalidReason
	export function newCertPool():Ref<CertPool>
	export const NotAuthorizedToSign:InvalidReason
	export interface PEMCipher extends int{
	}
	export const PEMCipher3DES:PEMCipher
	export const PEMCipherAES128:PEMCipher
	export const PEMCipherAES192:PEMCipher
	export const PEMCipherAES256:PEMCipher
	export const PEMCipherDES:PEMCipher
	export function parseCRL(crlBytes:Uint8Array):Ref<pkix.CertificateList>
	export function parseCertificate(der:Uint8Array):Ref<Certificate>
	export function parseCertificateRequest(asn1Data:Uint8Array):Ref<CertificateRequest>
	export function parseCertificates(der:Uint8Array):[Ref<Certificate>]
	export function parseDERCRL(derBytes:Uint8Array):Ref<pkix.CertificateList>
	export function parseECPrivateKey(der:Uint8Array):Ref<ecdsa.PrivateKey>
	export function parsePKCS1PrivateKey(der:Uint8Array):Ref<rsa.PrivateKey>
	export function parsePKCS1PublicKey(der:Uint8Array):Ref<rsa.PublicKey>
	export function parsePKCS8PrivateKey(der:Uint8Array):any
	export function parsePKIXPublicKey(derBytes:Uint8Array):any
	export function parseRevocationList(der:Uint8Array):Ref<RevocationList>
	export interface PublicKeyAlgorithm extends int{
		string():string
	}
	export const PureEd25519:SignatureAlgorithm
	export const RSA:PublicKeyAlgorithm
	export interface RevocationList extends crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey,Struct<RevocationList>{
		raw:Uint8Array
		rawTBSRevocationList:Uint8Array
		rawIssuer:Uint8Array
		issuer:pkix.Name
		authorityKeyId:Uint8Array
		signature:Uint8Array
		signatureAlgorithm:SignatureAlgorithm
		revokedCertificateEntries:RevocationListEntry[]
		revokedCertificates:pkix.RevokedCertificate[]
		number:Ref<big.Int>
		thisUpdate:time.Time
		nextUpdate:time.Time
		extensions:pkix.Extension[]
		extraExtensions:pkix.Extension[]
		checkSignatureFrom(parent:Ref<Certificate>):error
	}
	export interface RevocationListEntry extends Struct<RevocationListEntry>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey{
		raw:Uint8Array
		serialNumber:Ref<big.Int>
		revocationTime:time.Time
		reasonCode:int
		extensions:pkix.Extension[]
		extraExtensions:pkix.Extension[]
	}
	export const SHA1WithRSA:SignatureAlgorithm
	export const SHA256WithRSA:SignatureAlgorithm
	export const SHA256WithRSAPSS:SignatureAlgorithm
	export const SHA384WithRSA:SignatureAlgorithm
	export const SHA384WithRSAPSS:SignatureAlgorithm
	export const SHA512WithRSA:SignatureAlgorithm
	export const SHA512WithRSAPSS:SignatureAlgorithm
	export function setFallbackRoots(roots:Ref<CertPool>):void
	export interface SignatureAlgorithm extends int{
		string():string
	}
	export function systemCertPool():Ref<CertPool>
	export interface SystemRootsError extends Struct<SystemRootsError>,Error,GoError{
		err:GoError
		error():string
		unwrap():error
	}
	export const TooManyConstraints:InvalidReason
	export const TooManyIntermediates:InvalidReason
	export const UnconstrainedName:InvalidReason
	export interface UnhandledCriticalExtension extends Struct<UnhandledCriticalExtension>,crypto.PrivateKey,crypto.DecrypterOpts,crypto.PublicKey,GoError,Alias<Nothing>{
		error():string
	}
	export interface UnknownAuthorityError extends Struct<UnknownAuthorityError>,Error,GoError{
		cert:Ref<Certificate>
		error():string
	}
	export const UnknownPublicKeyAlgorithm:PublicKeyAlgorithm
	export const UnknownSignatureAlgorithm:SignatureAlgorithm
	export interface VerifyOptions extends Struct<VerifyOptions>,crypto.DecrypterOpts,crypto.PublicKey,crypto.PrivateKey{
		dnsName:string
		intermediates:Ref<CertPool>
		roots:Ref<CertPool>
		currentTime:time.Time
		keyUsages:ExtKeyUsage[]
		maxConstraintComparisions:int
	}

export function emptyCertPool():CertPool
export function refCertPool():Ref<CertPool>
export function refOfCertPool(x:CertPool):Ref<CertPool>
export function emptyCertificate():Certificate
export function refCertificate():Ref<Certificate>
export function refOfCertificate(x:Certificate):Ref<Certificate>
export function emptyRevocationList():RevocationList
export function refRevocationList():Ref<RevocationList>
export function refOfRevocationList(x:RevocationList):Ref<RevocationList>
export function emptyRevocationListEntry():RevocationListEntry
export function refRevocationListEntry():Ref<RevocationListEntry>
export function refOfRevocationListEntry(x:RevocationListEntry):Ref<RevocationListEntry>
export function emptyUnhandledCriticalExtension():UnhandledCriticalExtension
export function refUnhandledCriticalExtension():Ref<UnhandledCriticalExtension>
export function refOfUnhandledCriticalExtension(x:UnhandledCriticalExtension):Ref<UnhandledCriticalExtension>
export function emptyCertificateRequest():CertificateRequest
export function refCertificateRequest():Ref<CertificateRequest>
export function refOfCertificateRequest(x:CertificateRequest):Ref<CertificateRequest>
export function emptyVerifyOptions():VerifyOptions
export function refVerifyOptions():Ref<VerifyOptions>
export function refOfVerifyOptions(x:VerifyOptions):Ref<VerifyOptions>}
