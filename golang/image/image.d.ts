// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/image'{
	// @ts-ignore
	import * as color from 'golang/image/color'
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import type {Struct,bool,Ref,error,GoError,uint8,uint32,int} from 'go'
	export interface Alpha extends Struct<Alpha>,RGBA64Image{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		alphaAt(x:int,y:int):color.Alpha
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setAlpha(x:int,y:int,c:color.Alpha):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface Alpha16 extends RGBA64Image,Struct<Alpha16>{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		alpha16At(x:int,y:int):color.Alpha16
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setAlpha16(x:int,y:int,c:color.Alpha16):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export const Black:Ref<Uniform>
	export interface CMYK extends Struct<CMYK>,RGBA64Image{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		cmykAt(x:int,y:int):color.CMYK
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setCMYK(x:int,y:int,c:color.CMYK):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface Config extends Struct<Config>{
		colorModel:color.Model
		width:int
		height:int
	}
	export function decode(r:io.Reader):[Image,string,error]
	export function decodeConfig(r:io.Reader):[Config,string,error]
	export const ErrFormat:GoError
	export interface Gray extends RGBA64Image,Struct<Gray>{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		grayAt(x:int,y:int):color.Gray
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setGray(x:int,y:int,c:color.Gray):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface Gray16 extends RGBA64Image,Struct<Gray16>{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		gray16At(x:int,y:int):color.Gray16
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setGray16(x:int,y:int,c:color.Gray16):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface Image{
		at(x:int,y:int):color.Color
		bounds():Rectangle
		colorModel():color.Model
	}
	export interface NRGBA extends Struct<NRGBA>,RGBA64Image{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		nrgbaAt(x:int,y:int):color.NRGBA
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setNRGBA(x:int,y:int,c:color.NRGBA):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface NRGBA64 extends RGBA64Image,Struct<NRGBA64>{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		nrgbA64At(x:int,y:int):color.NRGBA64
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setNRGBA64(x:int,y:int,c:color.NRGBA64):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface NYCbCrA extends Struct<NYCbCrA>,RGBA64Image{
		yCbCr:YCbCr
		A:Uint8Array
		aStride:int
		colorModel():color.Model
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		nyCbCrAAt(x:int,y:int):color.NYCbCrA
		aOffset(x:int,y:int):int
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export function newAlpha(r:Rectangle):Ref<Alpha>
	export function newAlpha16(r:Rectangle):Ref<Alpha16>
	export function newCMYK(r:Rectangle):Ref<CMYK>
	export function newGray(r:Rectangle):Ref<Gray>
	export function newGray16(r:Rectangle):Ref<Gray16>
	export function newNRGBA(r:Rectangle):Ref<NRGBA>
	export function newNRGBA64(r:Rectangle):Ref<NRGBA64>
	export function newNYCbCrA(r:Rectangle,subsampleRatio:YCbCrSubsampleRatio):Ref<NYCbCrA>
	export function newPaletted(r:Rectangle,p:color.Palette):Ref<Paletted>
	export function newRGBA(r:Rectangle):Ref<RGBA>
	export function newRGBA64(r:Rectangle):Ref<RGBA64>
	export function newUniform(c:color.Color):Ref<Uniform>
	export function newYCbCr(r:Rectangle,subsampleRatio:YCbCrSubsampleRatio):Ref<YCbCr>
	export const Opaque:Ref<Uniform>
	export interface Paletted extends Struct<Paletted>,RGBA64Image,PalettedImage{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		palette:color.Palette
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		colorIndexAt(x:int,y:int):uint8
		setColorIndex(x:int,y:int,index:uint8):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface PalettedImage extends Image{
		colorIndexAt(x:int,y:int):uint8
	}
	export interface Point extends Struct<Point>{
		X:int
		Y:int
		string():string
		add(q:Point):Point
		sub(q:Point):Point
		mul(k:int):Point
		div(k:int):Point
		In(r:Rectangle):bool
		mod(r:Rectangle):Point
		eq(q:Point):bool
	}
	export function pt(X:int,Y:int):Point
	export interface RGBA extends Struct<RGBA>,RGBA64Image{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		rgbaAt(x:int,y:int):color.RGBA
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		setRGBA(x:int,y:int,c:color.RGBA):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface RGBA64 extends RGBA64Image,Struct<RGBA64>{
		pix:Uint8Array
		stride:int
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		pixOffset(x:int,y:int):int
		set(x:int,y:int,c:color.Color):void
		setRGBA64(x:int,y:int,c:color.RGBA64):void
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface RGBA64Image extends Image{
		rgbA64At(x:int,y:int):color.RGBA64
	}
	export function rect(x0:int,y0:int,x1:int,y1:int):Rectangle
	export interface Rectangle extends Struct<Rectangle>,RGBA64Image{
		min:Point
		max:Point
		string():string
		dx():int
		dy():int
		size():Point
		add(p:Point):Rectangle
		sub(p:Point):Rectangle
		inset(n:int):Rectangle
		intersect(s:Rectangle):Rectangle
		union(s:Rectangle):Rectangle
		empty():bool
		eq(s:Rectangle):bool
		overlaps(s:Rectangle):bool
		In(s:Rectangle):bool
		canon():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		bounds():Rectangle
		colorModel():color.Model
	}
	export function registerFormat(name:string,magic:string,decode:(v1:io.Reader)=>[Image,error],decodeConfig:(v1:io.Reader)=>[Config,error]):void
	export const Transparent:Ref<Uniform>
	export interface Uniform extends Struct<Uniform>,RGBA64Image,color.Color,color.Model{
		C:color.Color
		rgba():[uint32,uint32,uint32,uint32]
		colorModel():color.Model
		convert(v1:color.Color):color.Color
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		opaque():bool
	}
	export const White:Ref<Uniform>
	export interface YCbCr extends Struct<YCbCr>,RGBA64Image{
		Y:Uint8Array
		cb:Uint8Array
		cr:Uint8Array
		yStride:int
		cStride:int
		subsampleRatio:YCbCrSubsampleRatio
		rect:Rectangle
		colorModel():color.Model
		bounds():Rectangle
		at(x:int,y:int):color.Color
		rgbA64At(x:int,y:int):color.RGBA64
		yCbCrAt(x:int,y:int):color.YCbCr
		yOffset(x:int,y:int):int
		cOffset(x:int,y:int):int
		subImage(r:Rectangle):Image
		opaque():bool
	}
	export interface YCbCrSubsampleRatio extends int{
		string():string
	}
	export const YCbCrSubsampleRatio410:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio411:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio420:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio422:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio440:YCbCrSubsampleRatio
	export const YCbCrSubsampleRatio444:YCbCrSubsampleRatio
	export const ZP:Point
	export const ZR:Rectangle

export function emptyPoint():Point
export function refPoint():Ref<Point>
export function refOfPoint(x:Point):Ref<Point>
export function emptyAlpha():Alpha
export function refAlpha():Ref<Alpha>
export function refOfAlpha(x:Alpha):Ref<Alpha>
export function emptyAlpha16():Alpha16
export function refAlpha16():Ref<Alpha16>
export function refOfAlpha16(x:Alpha16):Ref<Alpha16>
export function emptyPaletted():Paletted
export function refPaletted():Ref<Paletted>
export function refOfPaletted(x:Paletted):Ref<Paletted>
export function emptyCMYK():CMYK
export function refCMYK():Ref<CMYK>
export function refOfCMYK(x:CMYK):Ref<CMYK>
export function emptyConfig():Config
export function refConfig():Ref<Config>
export function refOfConfig(x:Config):Ref<Config>
export function emptyNRGBA64():NRGBA64
export function refNRGBA64():Ref<NRGBA64>
export function refOfNRGBA64(x:NRGBA64):Ref<NRGBA64>
export function emptyNYCbCrA():NYCbCrA
export function refNYCbCrA():Ref<NYCbCrA>
export function refOfNYCbCrA(x:NYCbCrA):Ref<NYCbCrA>
export function emptyRGBA64():RGBA64
export function refRGBA64():Ref<RGBA64>
export function refOfRGBA64(x:RGBA64):Ref<RGBA64>
export function emptyRectangle():Rectangle
export function refRectangle():Ref<Rectangle>
export function refOfRectangle(x:Rectangle):Ref<Rectangle>
export function emptyUniform():Uniform
export function refUniform():Ref<Uniform>
export function refOfUniform(x:Uniform):Ref<Uniform>
export function emptyYCbCr():YCbCr
export function refYCbCr():Ref<YCbCr>
export function refOfYCbCr(x:YCbCr):Ref<YCbCr>
export function emptyGray():Gray
export function refGray():Ref<Gray>
export function refOfGray(x:Gray):Ref<Gray>
export function emptyGray16():Gray16
export function refGray16():Ref<Gray16>
export function refOfGray16(x:Gray16):Ref<Gray16>
export function emptyNRGBA():NRGBA
export function refNRGBA():Ref<NRGBA>
export function refOfNRGBA(x:NRGBA):Ref<NRGBA>
export function emptyRGBA():RGBA
export function refRGBA():Ref<RGBA>
export function refOfRGBA(x:RGBA):Ref<RGBA>}
