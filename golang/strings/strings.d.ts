// noinspection JSUnusedGlobalSymbols,SpellCheckingInspection
// Code generated by define_gene; DO NOT EDIT.
declare module 'golang/strings'{
	// @ts-ignore
	import * as io from 'golang/io'
	// @ts-ignore
	import * as unicode from 'golang/unicode'
	// @ts-ignore
	import type {byte,rune,bool,Ref,int64,Struct,int,error} from 'go'
	export interface Builder extends io.Writer,io.ByteWriter,Struct<Builder>,io.StringWriter{
		string():string
		len():int
		cap():int
		reset():void
		grow(n:int):void
		write(p:Uint8Array):[int,error]
		writeByte(c:byte):error
		writeRune(r:rune):[int,error]
		writeString(s:string):[int,error]
	}
	export function clone(s:string):string
	export function compare(a:string,b:string):int
	export function contains(s:string,substr:string):bool
	export function containsAny(s:string,chars:string):bool
	export function containsFunc(s:string,f:(v1:rune)=>bool):bool
	export function containsRune(s:string,r:rune):bool
	export function count(s:string,substr:string):int
	export function cut(s:string,sep:string):[string,string,bool]
	export function cutPrefix(s:string,prefix:string):[string,bool]
	export function cutSuffix(s:string,suffix:string):[string,bool]
	export function equalFold(s:string,t:string):bool
	export function fields(s:string):string[]
	export function fieldsFunc(s:string,f:(v1:rune)=>bool):string[]
	export function hasPrefix(s:string,prefix:string):bool
	export function hasSuffix(s:string,suffix:string):bool
	export function index(s:string,substr:string):int
	export function indexAny(s:string,chars:string):int
	export function indexByte(s:string,c:byte):int
	export function indexFunc(s:string,f:(v1:rune)=>bool):int
	export function indexRune(s:string,r:rune):int
	export function join(elems:string[],sep:string):string
	export function lastIndex(s:string,substr:string):int
	export function lastIndexAny(s:string,chars:string):int
	export function lastIndexByte(s:string,c:byte):int
	export function lastIndexFunc(s:string,f:(v1:rune)=>bool):int
	export function map(mapping:(v1:rune)=>rune,s:string):string
	export function newReader(s:string):Ref<Reader>
	export function newReplacer(...oldnew:string[]):Ref<Replacer>
	export interface Reader extends io.ReadSeeker,io.ReaderAt,io.WriterTo,io.RuneScanner,io.ByteScanner,Struct<Reader>{
		len():int
		size():int64
		read(b:Uint8Array):[int,error]
		readAt(b:Uint8Array,off:int64):[int,error]
		readByte():[byte,error]
		unreadByte():error
		readRune():[rune,int,error]
		unreadRune():error
		seek(offset:int64,whence:int):[int64,error]
		writeTo(w:io.Writer):[int64,error]
		reset(s:string):void
	}
	export function repeat(s:string,count:int):string
	export function replace(s:string,old:string,New:string,n:int):string
	export function replaceAll(s:string,old:string,New:string):string
	export interface Replacer extends Struct<Replacer>{
		replace(s:string):string
		writeString(w:io.Writer,s:string):[int,error]
	}
	export function split(s:string,sep:string):string[]
	export function splitAfter(s:string,sep:string):string[]
	export function splitAfterN(s:string,sep:string,n:int):string[]
	export function splitN(s:string,sep:string,n:int):string[]
	export function title(s:string):string
	export function toLower(s:string):string
	export function toLowerSpecial(c:unicode.SpecialCase,s:string):string
	export function toTitle(s:string):string
	export function toTitleSpecial(c:unicode.SpecialCase,s:string):string
	export function toUpper(s:string):string
	export function toUpperSpecial(c:unicode.SpecialCase,s:string):string
	export function toValidUTF8(s:string,replacement:string):string
	export function trim(s:string,cutset:string):string
	export function trimFunc(s:string,f:(v1:rune)=>bool):string
	export function trimLeft(s:string,cutset:string):string
	export function trimLeftFunc(s:string,f:(v1:rune)=>bool):string
	export function trimPrefix(s:string,prefix:string):string
	export function trimRight(s:string,cutset:string):string
	export function trimRightFunc(s:string,f:(v1:rune)=>bool):string
	export function trimSpace(s:string):string
	export function trimSuffix(s:string,suffix:string):string

export function emptyBuilder():Builder
export function refBuilder():Ref<Builder>
export function refOfBuilder(x:Builder):Ref<Builder>
export function emptyReader():Reader
export function refReader():Ref<Reader>
export function refOfReader(x:Reader):Ref<Reader>
export function emptyReplacer():Replacer
export function refReplacer():Ref<Replacer>
export function refOfReplacer(x:Replacer):Ref<Replacer>}
