// Code generated by define_gene; DO NOT EDIT.
package reflect

import (
	_ "embed"
	"github.com/ZenLiuCN/engine"

	"reflect"
)

var (
	//go:embed reflect.d.ts
	ReflectDefine   []byte
	ReflectDeclared = map[string]any{
		"select":          reflect.Select,
		"SelectSend":      reflect.SelectSend,
		"Uint8":           reflect.Uint8,
		"valueOf":         reflect.ValueOf,
		"visibleFields":   reflect.VisibleFields,
		"String":          reflect.String,
		"Uint64":          reflect.Uint64,
		"BothDir":         reflect.BothDir,
		"copy":            reflect.Copy,
		"Float32":         reflect.Float32,
		"Int":             reflect.Int,
		"makeSlice":       reflect.MakeSlice,
		"SelectRecv":      reflect.SelectRecv,
		"Chan":            reflect.Chan,
		"chanOf":          reflect.ChanOf,
		"Invalid":         reflect.Invalid,
		"RecvDir":         reflect.RecvDir,
		"Uintptr":         reflect.Uintptr,
		"Int16":           reflect.Int16,
		"ptrTo":           reflect.PtrTo,
		"SendDir":         reflect.SendDir,
		"swapper":         reflect.Swapper,
		"typeOf":          reflect.TypeOf,
		"Uint32":          reflect.Uint32,
		"Array":           reflect.Array,
		"makeMap":         reflect.MakeMap,
		"sliceOf":         reflect.SliceOf,
		"arrayOf":         reflect.ArrayOf,
		"Complex128":      reflect.Complex128,
		"Bool":            reflect.Bool,
		"newAt":           reflect.NewAt,
		"pointerTo":       reflect.PointerTo,
		"Struct":          reflect.Struct,
		"append":          reflect.Append,
		"Complex64":       reflect.Complex64,
		"Func":            reflect.Func,
		"Pointer":         reflect.Pointer,
		"Uint":            reflect.Uint,
		"deepEqual":       reflect.DeepEqual,
		"funcOf":          reflect.FuncOf,
		"Int8":            reflect.Int8,
		"Map":             reflect.Map,
		"Ptr":             reflect.Ptr,
		"indirect":        reflect.Indirect,
		"Int32":           reflect.Int32,
		"Interface":       reflect.Interface,
		"mapOf":           reflect.MapOf,
		"SelectDefault":   reflect.SelectDefault,
		"appendSlice":     reflect.AppendSlice,
		"makeFunc":        reflect.MakeFunc,
		"structOf":        reflect.StructOf,
		"Uint16":          reflect.Uint16,
		"UnsafePointer":   reflect.UnsafePointer,
		"Float64":         reflect.Float64,
		"Slice":           reflect.Slice,
		"zero":            reflect.Zero,
		"Int64":           reflect.Int64,
		"makeMapWithSize": reflect.MakeMapWithSize,
		"New":             reflect.New,
		"makeChan":        reflect.MakeChan,

		"emptyMapIter": func() (v reflect.MapIter) {
			return v
		},
		"refMapIter": func() *reflect.MapIter {
			var x reflect.MapIter
			return &x
		},
		"refOfMapIter": func(x reflect.MapIter) *reflect.MapIter {
			return &x
		},
		"emptyMethod": func() (v reflect.Method) {
			return v
		},
		"refMethod": func() *reflect.Method {
			var x reflect.Method
			return &x
		},
		"refOfMethod": func(x reflect.Method) *reflect.Method {
			return &x
		},
		"emptySelectCase": func() (v reflect.SelectCase) {
			return v
		},
		"refSelectCase": func() *reflect.SelectCase {
			var x reflect.SelectCase
			return &x
		},
		"refOfSelectCase": func(x reflect.SelectCase) *reflect.SelectCase {
			return &x
		},
		"emptySliceHeader": func() (v reflect.SliceHeader) {
			return v
		},
		"refSliceHeader": func() *reflect.SliceHeader {
			var x reflect.SliceHeader
			return &x
		},
		"refOfSliceHeader": func(x reflect.SliceHeader) *reflect.SliceHeader {
			return &x
		},
		"emptyStringHeader": func() (v reflect.StringHeader) {
			return v
		},
		"refStringHeader": func() *reflect.StringHeader {
			var x reflect.StringHeader
			return &x
		},
		"refOfStringHeader": func(x reflect.StringHeader) *reflect.StringHeader {
			return &x
		},
		"emptyStructField": func() (v reflect.StructField) {
			return v
		},
		"refStructField": func() *reflect.StructField {
			var x reflect.StructField
			return &x
		},
		"refOfStructField": func(x reflect.StructField) *reflect.StructField {
			return &x
		},
		"emptyValue": func() (v reflect.Value) {
			return v
		},
		"refValue": func() *reflect.Value {
			var x reflect.Value
			return &x
		},
		"refOfValue": func(x reflect.Value) *reflect.Value {
			return &x
		}}
)

func init() {
	engine.RegisterModule(ReflectModule{})
}

type ReflectModule struct{}

func (S ReflectModule) Identity() string {
	return "golang/reflect"
}
func (S ReflectModule) TypeDefine() []byte {
	return ReflectDefine
}
func (S ReflectModule) Exports() map[string]any {
	return ReflectDeclared
}
